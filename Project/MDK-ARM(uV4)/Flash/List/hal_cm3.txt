; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\hal_cm3.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\hal_cm3.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\RTX\inc -I..\..\RTX\portable -I..\..\User\CpuFlash -I..\..\User\CRC8_16 -I..\..\User\DS1302 -I..\..\User\DWT -I..\..\User\IIC -I..\..\User\IWDG -I..\..\User\Key -I..\..\User\Led -I..\..\User\Net -I..\..\User\Protocal -I..\..\User\Reader -I..\..\User\SPI -I..\..\User\Timer -I..\..\User\Uart -I..\..\User\Param -I..\..\User\ADC -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\hal_cm3.crf ..\..\RTX\portable\HAL_CM3.c]
                          THUMB

                          AREA ||i.dbg_init||, CODE, READONLY, ALIGN=2

                  dbg_init PROC
;;;313    
;;;314    void dbg_init (void) {
000000  4809              LDR      r0,|L1.40|
;;;315      if ((DEMCR & DEMCR_TRCENA)     && 
000002  6800              LDR      r0,[r0,#0]
000004  f0107f80          TST      r0,#0x1000000
000008  d00d              BEQ      |L1.38|
;;;316          (ITM_CONTROL & ITM_ITMENA) &&
00000a  4808              LDR      r0,|L1.44|
00000c  6800              LDR      r0,[r0,#0]
00000e  f0100f01          TST      r0,#1
000012  d008              BEQ      |L1.38|
;;;317          (ITM_ENABLE & (1UL << 31))) {
000014  4805              LDR      r0,|L1.44|
000016  3880              SUBS     r0,r0,#0x80
000018  6800              LDR      r0,[r0,#0]
00001a  f0104f00          TST      r0,#0x80000000
00001e  d002              BEQ      |L1.38|
;;;318        dbg_msg = __TRUE;
000020  2001              MOVS     r0,#1
000022  4903              LDR      r1,|L1.48|
000024  7008              STRB     r0,[r1,#0]
                  |L1.38|
;;;319      }
;;;320    }
000026  4770              BX       lr
;;;321    
                          ENDP

                  |L1.40|
                          DCD      0xe000edfc
                  |L1.44|
                          DCD      0xe0000e80
                  |L1.48|
                          DCD      dbg_msg

                          AREA ||i.dbg_task_notify||, CODE, READONLY, ALIGN=2

                  dbg_task_notify PROC
;;;324    
;;;325    void dbg_task_notify (P_TCB p_tcb, BOOL create) {
000000  bf00              NOP      
                  |L2.2|
;;;326      while (ITM_PORT31_U32 == 0);
000002  f04f4260          MOV      r2,#0xe0000000
000006  6fd2              LDR      r2,[r2,#0x7c]
000008  2a00              CMP      r2,#0
00000a  d0fa              BEQ      |L2.2|
;;;327      ITM_PORT31_U32 = (U32)p_tcb->ptask;
00000c  f04f4360          MOV      r3,#0xe0000000
000010  6b42              LDR      r2,[r0,#0x34]
000012  67da              STR      r2,[r3,#0x7c]
;;;328      while (ITM_PORT31_U32 == 0);
000014  bf00              NOP      
                  |L2.22|
000016  f04f4260          MOV      r2,#0xe0000000
00001a  6fd2              LDR      r2,[r2,#0x7c]
00001c  2a00              CMP      r2,#0
00001e  d0fa              BEQ      |L2.22|
;;;329      ITM_PORT31_U16 = (create << 8) | p_tcb->task_id;
000020  78c2              LDRB     r2,[r0,#3]
000022  ea422201          ORR      r2,r2,r1,LSL #8
000026  4b01              LDR      r3,|L2.44|
000028  801a              STRH     r2,[r3,#0]
;;;330    }
00002a  4770              BX       lr
;;;331    
                          ENDP

                  |L2.44|
                          DCD      0xe000007c

                          AREA ||i.dbg_task_switch||, CODE, READONLY, ALIGN=2

                  dbg_task_switch PROC
;;;334    
;;;335    void dbg_task_switch (U32 task_id) {
000000  bf00              NOP      
                  |L3.2|
;;;336      while (ITM_PORT31_U32 == 0);
000002  f04f4160          MOV      r1,#0xe0000000
000006  6fc9              LDR      r1,[r1,#0x7c]
000008  2900              CMP      r1,#0
00000a  d0fa              BEQ      |L3.2|
;;;337      ITM_PORT31_U8 = task_id;
00000c  4a01              LDR      r2,|L3.20|
00000e  7010              STRB     r0,[r2,#0]
;;;338    }
000010  4770              BX       lr
;;;339    
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0xe000007c

                          AREA ||i.rt_init_stack||, CODE, READONLY, ALIGN=2

                  rt_init_stack PROC
;;;268    
;;;269    void rt_init_stack (P_TCB p_TCB, FUNCP task_body) {
000000  b570              PUSH     {r4-r6,lr}
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;270      /* Prepare TCB and saved context for a first time start of a task. */
;;;271      U32 *stk,i,size;
;;;272    
;;;273      /* Prepare a complete interrupt frame for first task start */
;;;274      size = p_TCB->priv_stack >> 2;
000006  8d15              LDRH     r5,[r2,#0x28]
000008  10ac              ASRS     r4,r5,#2
;;;275      if (size == 0) {
00000a  b91c              CBNZ     r4,|L4.20|
;;;276        size = (U16)os_stackinfo >> 2;
00000c  4d0f              LDR      r5,|L4.76|
00000e  882d              LDRH     r5,[r5,#0]  ; os_stackinfo
000010  f3c5048d          UBFX     r4,r5,#2,#14
                  |L4.20|
;;;277      }
;;;278    
;;;279      /* Write to the top of stack. */
;;;280      stk = &p_TCB->stack[size];
000014  6b15              LDR      r5,[r2,#0x30]
000016  eb050084          ADD      r0,r5,r4,LSL #2
;;;281    
;;;282      /* Auto correct to 8-byte ARM stack alignment. */
;;;283      if ((U32)stk & 0x04) {
00001a  f0100f04          TST      r0,#4
00001e  d000              BEQ      |L4.34|
;;;284        stk--;
000020  1f00              SUBS     r0,r0,#4
                  |L4.34|
;;;285      }
;;;286    
;;;287      stk -= 16;
000022  3840              SUBS     r0,r0,#0x40
;;;288    
;;;289      /* Default xPSR and initial PC */
;;;290      stk[15] = INITIAL_xPSR;
000024  f04f7580          MOV      r5,#0x1000000
000028  63c5              STR      r5,[r0,#0x3c]
;;;291      stk[14] = (U32)task_body;
00002a  6383              STR      r3,[r0,#0x38]
;;;292    
;;;293      /* Clear R1-R12,LR registers. */
;;;294      for (i = 0; i < 14; i++) {
00002c  2100              MOVS     r1,#0
00002e  e003              B        |L4.56|
                  |L4.48|
;;;295        stk[i] = 0;
000030  2500              MOVS     r5,#0
000032  f8405021          STR      r5,[r0,r1,LSL #2]
000036  1c49              ADDS     r1,r1,#1              ;294
                  |L4.56|
000038  290e              CMP      r1,#0xe               ;294
00003a  d3f9              BCC      |L4.48|
;;;296      }
;;;297    
;;;298      /* Assign a void pointer to R0. */
;;;299      stk[8] = (U32)p_TCB->msg;
00003c  69d5              LDR      r5,[r2,#0x1c]
00003e  6205              STR      r5,[r0,#0x20]
;;;300    
;;;301      /* Initial Task stack pointer. */
;;;302      p_TCB->tsk_stack = (U32)stk;
000040  62d0              STR      r0,[r2,#0x2c]
;;;303    
;;;304      /* Task entry point. */
;;;305      p_TCB->ptask = task_body;
000042  6353              STR      r3,[r2,#0x34]
;;;306    
;;;307      /* Set a magic word for checking of stack overflow. */
;;;308      p_TCB->stack[0] = MAGIC_WORD;
000044  4d02              LDR      r5,|L4.80|
000046  6b16              LDR      r6,[r2,#0x30]
000048  6035              STR      r5,[r6,#0]
;;;309    }
00004a  bd70              POP      {r4-r6,pc}
;;;310    
                          ENDP

                  |L4.76|
                          DCD      os_stackinfo
                  |L4.80|
                          DCD      0xe25a2ea5

                          AREA ||.data||, DATA, ALIGN=0

                  dbg_msg
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\RTX\\portable\\HAL_CM3.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |rt_set_PSP|
#line 34
|rt_set_PSP| PROC
#line 34

 MSR PSP,R0
 BX LR
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |rt_get_PSP|
#line 42
|rt_get_PSP| PROC
#line 42

 MRS R0,PSP
 BX LR
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |os_set_env|
	IMPORT |os_flags|
#line 50
|os_set_env| PROC
#line 50

 
 MOV R0,SP 
 MSR PSP,R0
 LDR R0,= |os_flags|
 LDRB R0,[R0]
 LSLS R0,#31
 MOVNE R0,#0x02 
 MOVEQ R0,#0x03 
 MSR CONTROL,R0
 BX LR

 ALIGN
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |_alloc_box|
	IMPORT |rt_alloc_box|
#line 68
|_alloc_box| PROC
#line 68

 
 LDR R12,= |rt_alloc_box|
 MRS R3,IPSR
 LSLS R3,#24
 BXNE R12
 MRS R3,CONTROL
 LSLS R3,#31
 BXEQ R12
 SVC 0
 BX LR

 ALIGN
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |_free_box|
	IMPORT |rt_free_box|
#line 86
|_free_box| PROC
#line 86

 
 LDR R12,= |rt_free_box|
 MRS R3,IPSR
 LSLS R3,#24
 BXNE R12
 MRS R3,CONTROL
 LSLS R3,#31
 BXEQ R12
 SVC 0
 BX LR

 ALIGN
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |SVC_Handler|
	IMPORT |os_tsk|
#line 104
|SVC_Handler| PROC
#line 104

 PRESERVE8

#line 110


 IMPORT SVC_Count
 IMPORT SVC_Table
 IMPORT rt_stk_check

 MRS R0,PSP 
 LDR R1,[R0,#24] 
 LDRB R1,[R1,#-2] 
 CBNZ R1,SVC_User

 LDM R0,{R0-R3,R12} 
 BLX R12 

 MRS R12,PSP 
 LDR R3,= |os_tsk|
 LDM R3,{R1,R2} 
 CMP R1,R2
 BEQ SVC_Exit 

 CBZ R1,SVC_Restore 

 PUSH {R2,R3}
 MOV R3,#1
 STRB R3,[R1,#38] 
 STMDB R12!,{R4-R11} 
 STR R12,[R1,#44] 
 BL rt_stk_check 
 POP {R2,R3}

SVC_Restore
 STR R2,[R3] 

 LDR R12,[R2,#44] 
 LDMIA R12!,{R4-R11} 
 LDRB R3,[R2,#38] 
 MSR PSP,R12 

 CBZ R3,SVC_Return
 LDRB R0,[R2,#37] 

SVC_Exit
 STR R0,[R12] 

SVC_Return
 MVN LR,#:NOT:0xFFFFFFFD 
#line 159

 BX LR


 

SVC_User
 PUSH {R4,LR} 
 LDR R2,=SVC_Count
 LDR R2,[R2]
 CMP R1,R2
 BHI SVC_Done 

 LDR R4,=SVC_Table-4
 LDR R4,[R4,R1,LSL #2] 

 LDM R0,{R0-R3,R12} 
 BLX R4 

 MRS R12,PSP
 STM R12,{R0-R3} 
SVC_Done
 POP {R4,PC} 

 ALIGN
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |PendSV_Handler|
	IMPORT |rt_pop_req|
#line 189
|PendSV_Handler| PROC
#line 189

 PRESERVE8

#line 195


 BL  |rt_pop_req|

Sys_Switch
 LDR R3,= |os_tsk|
 LDM R3,{R1,R2} 
 CMP R1,R2
 BEQ Sys_Exit

 PUSH {R2,R3}
 MOV R3,#0
 STRB R3,[R1,#38] 
 MRS R12,PSP 
 STMDB R12!,{R4-R11} 
 STR R12,[R1,#44] 
 BL rt_stk_check 

 POP {R2,R3}
 STR R2,[R3] 

 LDR R12,[R2,#44] 
 LDMIA R12!,{R4-R11} 
 MSR PSP,R12 

 LDRB R3,[R2,#38] 
 CBZ R3,Sys_Exit
 LDRB R3,[R2,#37] 
 STR R3,[R12]
Sys_Exit
 MVN LR,#:NOT:0xFFFFFFFD 
#line 229

 BX LR 


 ALIGN
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |SysTick_Handler|
	IMPORT |rt_systick|
#line 239
|SysTick_Handler| PROC
#line 239

 PRESERVE8

#line 245


 BL  |rt_systick|
 B Sys_Switch

 ALIGN
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |OS_Tick_Handler|
	IMPORT |os_tick_irqack|
#line 256
|OS_Tick_Handler| PROC
#line 256

 PRESERVE8

 BL  |os_tick_irqack|
 BL  |rt_systick|
 B Sys_Switch

 ALIGN
	ENDP

;*** End   embedded assembler ***
