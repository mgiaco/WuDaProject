; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_eeprom_24xx.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_eeprom_24xx.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\RTX\inc -I..\..\RTX\portable -I..\..\User\CpuFlash -I..\..\User\CRC8_16 -I..\..\User\DS1302 -I..\..\User\DWT -I..\..\User\IIC -I..\..\User\IWDG -I..\..\User\Key -I..\..\User\Led -I..\..\User\Net -I..\..\User\Protocal -I..\..\User\Reader -I..\..\User\SPI -I..\..\User\Timer -I..\..\User\Uart -I..\..\User\Param -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_eeprom_24xx.crf ..\..\User\IIC\bsp_eeprom_24xx.c]
                          THUMB

                          AREA ||i.ee_CheckOk||, CODE, READONLY, ALIGN=1

                  ee_CheckOk PROC
;;;31     */
;;;32     uint8_t ee_CheckOk(void)
000000  b510              PUSH     {r4,lr}
;;;33     {
;;;34         if (i2c_CheckDevice(EE_DEV_ADDR) == 0)
000002  20a0              MOVS     r0,#0xa0
000004  f7fffffe          BL       i2c_CheckDevice
000008  b908              CBNZ     r0,|L1.14|
;;;35         {
;;;36             return 1;
00000a  2001              MOVS     r0,#1
                  |L1.12|
;;;37         }
;;;38         else
;;;39         {
;;;40             /* 失败后，切记发送I2C总线停止信号 */
;;;41             i2c_Stop();
;;;42             return 0;
;;;43         }
;;;44     }
00000c  bd10              POP      {r4,pc}
                  |L1.14|
00000e  f7fffffe          BL       i2c_Stop
000012  2000              MOVS     r0,#0                 ;42
000014  e7fa              B        |L1.12|
;;;45     
                          ENDP


                          AREA ||i.ee_ReadBytes||, CODE, READONLY, ALIGN=1

                  ee_ReadBytes PROC
;;;56     */
;;;57     uint8_t ee_ReadBytes(uint8_t *_pReadBuf, uint32_t _usAddress, uint16_t _usSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;58     {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;59         uint16_t i;
;;;60         uint8_t addP0 = _usAddress>>16;
00000a  f3c54807          UBFX     r8,r5,#16,#8
;;;61         
;;;62         /* 采用串行EEPROM随即读取指令序列，连续读取若干字节 */
;;;63         
;;;64         /* 第1步：发起I2C总线启动信号 */
;;;65         i2c_Start();
00000e  f7fffffe          BL       i2c_Start
;;;66         
;;;67         /* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;68        	/* 此处是写指令 */
;;;69         if(addP0 == 0)
000012  f1b80f00          CMP      r8,#0
000016  d103              BNE      |L2.32|
;;;70         {
;;;71             i2c_SendByte(EE_DEV_ADDR | I2C_WR);
000018  20a0              MOVS     r0,#0xa0
00001a  f7fffffe          BL       i2c_SendByte
00001e  e002              B        |L2.38|
                  |L2.32|
;;;72         }
;;;73         else i2c_SendByte(EE_DEV_ADDR | I2C_WR | 0x02);
000020  20a2              MOVS     r0,#0xa2
000022  f7fffffe          BL       i2c_SendByte
                  |L2.38|
;;;74         
;;;75         /* 第3步：发送ACK */
;;;76         if (i2c_WaitAck() != 0)
000026  f7fffffe          BL       i2c_WaitAck
00002a  b100              CBZ      r0,|L2.46|
;;;77         {
;;;78             goto cmd_fail;	/* EEPROM器件无应答 */
00002c  e034              B        |L2.152|
                  |L2.46|
;;;79         }
;;;80         
;;;81         /* 第4步：发送字节地址，24C02只有256字节，因此1个字节就够了，如果是24C04以上，那么此处需要连发多个地址 */
;;;82         if (EE_ADDR_BYTES == 1)
;;;83         {
;;;84             i2c_SendByte((uint8_t)_usAddress);
;;;85             if (i2c_WaitAck() != 0)
;;;86             {
;;;87                 goto cmd_fail;	/* EEPROM器件无应答 */
;;;88             }
;;;89         }
;;;90         else
;;;91         {
;;;92             i2c_SendByte(_usAddress >> 8);
00002e  f3c52007          UBFX     r0,r5,#8,#8
000032  f7fffffe          BL       i2c_SendByte
;;;93             if (i2c_WaitAck() != 0)
000036  f7fffffe          BL       i2c_WaitAck
00003a  b100              CBZ      r0,|L2.62|
;;;94             {
;;;95                 goto cmd_fail;	/* EEPROM器件无应答 */
00003c  e02c              B        |L2.152|
                  |L2.62|
;;;96             }
;;;97             
;;;98             i2c_SendByte(_usAddress & 0xFF);
00003e  b2e8              UXTB     r0,r5
000040  f7fffffe          BL       i2c_SendByte
;;;99             if (i2c_WaitAck() != 0)
000044  f7fffffe          BL       i2c_WaitAck
000048  b100              CBZ      r0,|L2.76|
;;;100            {
;;;101                goto cmd_fail;	/* EEPROM器件无应答 */
00004a  e025              B        |L2.152|
                  |L2.76|
;;;102            }
;;;103        }
;;;104        
;;;105        /* 第6步：重新启动I2C总线。下面开始读取数据 */
;;;106        i2c_Start();
00004c  f7fffffe          BL       i2c_Start
;;;107        
;;;108        /* 第7步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;109        /* 此处是读指令 */
;;;110        if(addP0 == 0)
000050  f1b80f00          CMP      r8,#0
000054  d103              BNE      |L2.94|
;;;111        {
;;;112            i2c_SendByte(EE_DEV_ADDR | I2C_RD);
000056  20a1              MOVS     r0,#0xa1
000058  f7fffffe          BL       i2c_SendByte
00005c  e002              B        |L2.100|
                  |L2.94|
;;;113        }
;;;114        else i2c_SendByte(EE_DEV_ADDR | I2C_RD | 0x02);
00005e  20a3              MOVS     r0,#0xa3
000060  f7fffffe          BL       i2c_SendByte
                  |L2.100|
;;;115        
;;;116        /* 第8步：发送ACK */
;;;117        if (i2c_WaitAck() != 0)
000064  f7fffffe          BL       i2c_WaitAck
000068  b100              CBZ      r0,|L2.108|
;;;118        {
;;;119            goto cmd_fail;	/* EEPROM器件无应答 */
00006a  e015              B        |L2.152|
                  |L2.108|
;;;120        }
;;;121        
;;;122        /* 第9步：循环读取数据 */
;;;123        for (i = 0; i < _usSize; i++)
00006c  2400              MOVS     r4,#0
00006e  e00c              B        |L2.138|
                  |L2.112|
;;;124        {
;;;125            _pReadBuf[i] = i2c_ReadByte();	/* 读1个字节 */
000070  f7fffffe          BL       i2c_ReadByte
000074  5538              STRB     r0,[r7,r4]
;;;126            
;;;127            /* 每读完1个字节后，需要发送Ack， 最后一个字节不需要Ack，发Nack */
;;;128            if (i != _usSize - 1)
000076  1e70              SUBS     r0,r6,#1
000078  42a0              CMP      r0,r4
00007a  d002              BEQ      |L2.130|
;;;129            {
;;;130                i2c_Ack();	/* 中间字节读完后，CPU产生ACK信号(驱动SDA = 0) */
00007c  f7fffffe          BL       i2c_Ack
000080  e001              B        |L2.134|
                  |L2.130|
;;;131            }
;;;132            else
;;;133            {
;;;134                i2c_NAck();	/* 最后1个字节读完后，CPU产生NACK信号(驱动SDA = 1) */
000082  f7fffffe          BL       i2c_NAck
                  |L2.134|
000086  1c60              ADDS     r0,r4,#1              ;123
000088  b284              UXTH     r4,r0                 ;123
                  |L2.138|
00008a  42b4              CMP      r4,r6                 ;123
00008c  dbf0              BLT      |L2.112|
;;;135            }
;;;136        }
;;;137        /* 发送I2C总线停止信号 */
;;;138        i2c_Stop();
00008e  f7fffffe          BL       i2c_Stop
;;;139        return 1;	/* 执行成功 */
000092  2001              MOVS     r0,#1
                  |L2.148|
;;;140        
;;;141    cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;142        /* 发送I2C总线停止信号 */
;;;143        i2c_Stop();
;;;144        return 0;
;;;145    }
000094  e8bd81f0          POP      {r4-r8,pc}
                  |L2.152|
000098  f7fffffe          BL       i2c_Stop
00009c  2000              MOVS     r0,#0                 ;144
00009e  e7f9              B        |L2.148|
;;;146    
                          ENDP


                          AREA ||i.ee_WriteBytes||, CODE, READONLY, ALIGN=1

                  ee_WriteBytes PROC
;;;156    */
;;;157    uint8_t ee_WriteBytes(uint8_t *_pWriteBuf, uint32_t _usAddress, uint16_t _usSize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;158    {
000004  4680              MOV      r8,r0
000006  460e              MOV      r6,r1
000008  4691              MOV      r9,r2
;;;159        uint16_t i,m;
;;;160        uint16_t usAddr;
;;;161        uint8_t addP0 = _usAddress>>16;
00000a  f3c64a07          UBFX     r10,r6,#16,#8
;;;162        /*
;;;163        写串行EEPROM不像读操作可以连续读取很多字节，每次写操作只能在同一个page。
;;;164        对于24xx02，page size = 8
;;;165        简单的处理方法为：按字节写操作模式，每写1个字节，都发送地址
;;;166        为了提高连续写的效率: 本函数采用page wirte操作。
;;;167        */
;;;168        
;;;169        usAddr = _usAddress;
00000e  b2b5              UXTH     r5,r6
;;;170        for (i = 0; i < _usSize; i++)
000010  2400              MOVS     r4,#0
000012  e03b              B        |L3.140|
                  |L3.20|
;;;171        {
;;;172            /* 当发送第1个字节或是页面首地址时，需要重新发起启动信号和地址 */
;;;173            if ((i == 0) || (usAddr & (EE_PAGE_SIZE - 1)) == 0)
000014  b114              CBZ      r4,|L3.28|
000016  f0150f1f          TST      r5,#0x1f
00001a  d12b              BNE      |L3.116|
                  |L3.28|
;;;174            {
;;;175                /*　第０步：发停止信号，启动内部写操作　*/
;;;176                i2c_Stop();
00001c  f7fffffe          BL       i2c_Stop
;;;177                
;;;178                /* 通过检查器件应答的方式，判断内部写操作是否完成, 一般小于 10ms
;;;179                CLK频率为200KHz时，查询次数为30次左右
;;;180                */
;;;181                for (m = 0; m < 1000; m++)
000020  2700              MOVS     r7,#0
000022  e011              B        |L3.72|
                  |L3.36|
;;;182                {
;;;183                    /* 第1步：发起I2C总线启动信号 */
;;;184                    i2c_Start();
000024  f7fffffe          BL       i2c_Start
;;;185                    
;;;186                    /* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;187                    /* 此处是写指令 */
;;;188                    if(addP0 == 0)
000028  f1ba0f00          CMP      r10,#0
00002c  d103              BNE      |L3.54|
;;;189                    {
;;;190                        i2c_SendByte(EE_DEV_ADDR | I2C_WR);	/* 此处是写指令 */
00002e  20a0              MOVS     r0,#0xa0
000030  f7fffffe          BL       i2c_SendByte
000034  e002              B        |L3.60|
                  |L3.54|
;;;191                    }
;;;192                    else i2c_SendByte(EE_DEV_ADDR | I2C_WR | 0x02);
000036  20a2              MOVS     r0,#0xa2
000038  f7fffffe          BL       i2c_SendByte
                  |L3.60|
;;;193                    
;;;194                    /* 第3步：发送一个时钟，判断器件是否正确应答 */
;;;195                    if (i2c_WaitAck() == 0)
00003c  f7fffffe          BL       i2c_WaitAck
000040  b900              CBNZ     r0,|L3.68|
;;;196                    {
;;;197                        break;
000042  e004              B        |L3.78|
                  |L3.68|
000044  1c78              ADDS     r0,r7,#1              ;181
000046  b287              UXTH     r7,r0                 ;181
                  |L3.72|
000048  f5b77f7a          CMP      r7,#0x3e8             ;181
00004c  dbea              BLT      |L3.36|
                  |L3.78|
00004e  bf00              NOP      
;;;198                    }
;;;199                }
;;;200                if (m  == 1000)
000050  f5b77f7a          CMP      r7,#0x3e8
000054  d100              BNE      |L3.88|
;;;201                {
;;;202                    goto cmd_fail;	/* EEPROM器件写超时 */
000056  e020              B        |L3.154|
                  |L3.88|
;;;203                }
;;;204                
;;;205                /* 第4步：发送字节地址，24C02只有256字节，因此1个字节就够了，如果是24C04以上，那么此处需要连发多个地址 */
;;;206                if (EE_ADDR_BYTES == 1)
;;;207                {
;;;208                    i2c_SendByte((uint8_t)usAddr);
;;;209                    if (i2c_WaitAck() != 0)
;;;210                    {
;;;211                        goto cmd_fail;	/* EEPROM器件无应答 */
;;;212                    }
;;;213                }
;;;214                else
;;;215                {
;;;216                    i2c_SendByte(usAddr >> 8);
000058  1228              ASRS     r0,r5,#8
00005a  f7fffffe          BL       i2c_SendByte
;;;217                    if (i2c_WaitAck() != 0)
00005e  f7fffffe          BL       i2c_WaitAck
000062  b100              CBZ      r0,|L3.102|
;;;218                    {
;;;219                        goto cmd_fail;	/* EEPROM器件无应答 */
000064  e019              B        |L3.154|
                  |L3.102|
;;;220                    }
;;;221                    
;;;222                    i2c_SendByte(usAddr & 0xFF);
000066  b2e8              UXTB     r0,r5
000068  f7fffffe          BL       i2c_SendByte
;;;223                    if (i2c_WaitAck() != 0)
00006c  f7fffffe          BL       i2c_WaitAck
000070  b100              CBZ      r0,|L3.116|
;;;224                    {
;;;225                        goto cmd_fail;	/* EEPROM器件无应答 */
000072  e012              B        |L3.154|
                  |L3.116|
;;;226                    }
;;;227                }
;;;228            }
;;;229            
;;;230            /* 第6步：开始写入数据 */
;;;231            i2c_SendByte(_pWriteBuf[i]);
000074  f8180004          LDRB     r0,[r8,r4]
000078  f7fffffe          BL       i2c_SendByte
;;;232            
;;;233            /* 第7步：发送ACK */
;;;234            if (i2c_WaitAck() != 0)
00007c  f7fffffe          BL       i2c_WaitAck
000080  b100              CBZ      r0,|L3.132|
;;;235            {
;;;236                goto cmd_fail;	/* EEPROM器件无应答 */
000082  e00a              B        |L3.154|
                  |L3.132|
;;;237            }
;;;238            
;;;239            usAddr++;	/* 地址增1 */
000084  1c68              ADDS     r0,r5,#1
000086  b285              UXTH     r5,r0
000088  1c60              ADDS     r0,r4,#1              ;170
00008a  b284              UXTH     r4,r0                 ;170
                  |L3.140|
00008c  454c              CMP      r4,r9                 ;170
00008e  dbc1              BLT      |L3.20|
;;;240        }
;;;241        
;;;242        /* 命令执行成功，发送I2C总线停止信号 */
;;;243        i2c_Stop();
000090  f7fffffe          BL       i2c_Stop
;;;244        return 1;
000094  2001              MOVS     r0,#1
                  |L3.150|
;;;245        
;;;246    cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;247        /* 发送I2C总线停止信号 */
;;;248        i2c_Stop();
;;;249        return 0;
;;;250    }
000096  e8bd87f0          POP      {r4-r10,pc}
                  |L3.154|
00009a  f7fffffe          BL       i2c_Stop
00009e  2000              MOVS     r0,#0                 ;249
0000a0  e7f9              B        |L3.150|
;;;251    
                          ENDP


                          AREA ||i.ee_WriteOneBytes||, CODE, READONLY, ALIGN=1

                  ee_WriteOneBytes PROC
;;;252    //单字节写入
;;;253    uint8_t ee_WriteOneBytes(uint8_t DataWrite, uint32_t usAddr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;254    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;255        uint16_t m = 0;
000008  2500              MOVS     r5,#0
;;;256        uint8_t addP0 = usAddr>>16;
00000a  f3c44707          UBFX     r7,r4,#16,#8
;;;257        /*　第０步：发停止信号，启动内部写操作　*/
;;;258        i2c_Stop();
00000e  f7fffffe          BL       i2c_Stop
;;;259        for (m = 0; m < 1000; m++)
000012  bf00              NOP      
000014  e00f              B        |L4.54|
                  |L4.22|
;;;260        {
;;;261            /* 第1步：发起I2C总线启动信号 */
;;;262            i2c_Start();
000016  f7fffffe          BL       i2c_Start
;;;263            
;;;264            /* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;265            /* 此处是写指令 */
;;;266            if(addP0 == 0)
00001a  b91f              CBNZ     r7,|L4.36|
;;;267            {
;;;268                i2c_SendByte(EE_DEV_ADDR | I2C_WR);	/* 此处是写指令 */
00001c  20a0              MOVS     r0,#0xa0
00001e  f7fffffe          BL       i2c_SendByte
000022  e002              B        |L4.42|
                  |L4.36|
;;;269            }
;;;270            else i2c_SendByte(EE_DEV_ADDR | I2C_WR | 0x02);
000024  20a2              MOVS     r0,#0xa2
000026  f7fffffe          BL       i2c_SendByte
                  |L4.42|
;;;271            
;;;272            /* 第3步：发送一个时钟，判断器件是否正确应答 */
;;;273            if (i2c_WaitAck() == 0)
00002a  f7fffffe          BL       i2c_WaitAck
00002e  b900              CBNZ     r0,|L4.50|
;;;274            {
;;;275                break;
000030  e004              B        |L4.60|
                  |L4.50|
000032  1c68              ADDS     r0,r5,#1              ;259
000034  b285              UXTH     r5,r0                 ;259
                  |L4.54|
000036  f5b57f7a          CMP      r5,#0x3e8             ;259
00003a  dbec              BLT      |L4.22|
                  |L4.60|
00003c  bf00              NOP      
;;;276            }
;;;277        }
;;;278        if (m  == 1000)
00003e  f5b57f7a          CMP      r5,#0x3e8
000042  d100              BNE      |L4.70|
;;;279        {
;;;280            goto cmd_fail;	/* EEPROM器件写超时 */
000044  e01a              B        |L4.124|
                  |L4.70|
;;;281        }
;;;282        
;;;283        /* 第4步：发送字节地址，24C02只有256字节，因此1个字节就够了，如果是24C04以上，那么此处需要连发多个地址 */
;;;284        if (EE_ADDR_BYTES == 1)
;;;285        {
;;;286            i2c_SendByte((uint8_t)usAddr);
;;;287            if (i2c_WaitAck() != 0)
;;;288            {
;;;289                goto cmd_fail;	/* EEPROM器件无应答 */
;;;290            }
;;;291        }
;;;292        else
;;;293        {
;;;294            i2c_SendByte(usAddr >> 8);//高8位
000046  f3c42007          UBFX     r0,r4,#8,#8
00004a  f7fffffe          BL       i2c_SendByte
;;;295            if (i2c_WaitAck() != 0)
00004e  f7fffffe          BL       i2c_WaitAck
000052  b100              CBZ      r0,|L4.86|
;;;296            {
;;;297                goto cmd_fail;	/* EEPROM器件无应答 */
000054  e012              B        |L4.124|
                  |L4.86|
;;;298            }
;;;299            
;;;300            i2c_SendByte(usAddr & 0xFF);//低8位
000056  b2e0              UXTB     r0,r4
000058  f7fffffe          BL       i2c_SendByte
;;;301            if (i2c_WaitAck() != 0)
00005c  f7fffffe          BL       i2c_WaitAck
000060  b100              CBZ      r0,|L4.100|
;;;302            {
;;;303                goto cmd_fail;	/* EEPROM器件无应答 */
000062  e00b              B        |L4.124|
                  |L4.100|
;;;304            }
;;;305        }
;;;306        /* 第6步：开始写入数据 */
;;;307        i2c_SendByte(DataWrite);
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       i2c_SendByte
;;;308        
;;;309        /* 第7步：发送ACK */
;;;310        if (i2c_WaitAck() != 0)
00006a  f7fffffe          BL       i2c_WaitAck
00006e  b100              CBZ      r0,|L4.114|
;;;311        {
;;;312            goto cmd_fail;	/* EEPROM器件无应答 */
000070  e004              B        |L4.124|
                  |L4.114|
;;;313        }
;;;314        /* 命令执行成功，发送I2C总线停止信号 */
;;;315        i2c_Stop();
000072  f7fffffe          BL       i2c_Stop
;;;316        return 1;
000076  2001              MOVS     r0,#1
                  |L4.120|
;;;317        
;;;318    cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;319        /* 发送I2C总线停止信号 */
;;;320        i2c_Stop();
;;;321        return 0;
;;;322    }
000078  e8bd81f0          POP      {r4-r8,pc}
                  |L4.124|
00007c  f7fffffe          BL       i2c_Stop
000080  2000              MOVS     r0,#0                 ;321
000082  e7f9              B        |L4.120|
;;;323    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\User\\IIC\\bsp_eeprom_24xx.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___17_bsp_eeprom_24xx_c_4eb00f1b____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_bsp_eeprom_24xx_c_4eb00f1b____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___17_bsp_eeprom_24xx_c_4eb00f1b____REVSH|
#line 128
|__asm___17_bsp_eeprom_24xx_c_4eb00f1b____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
