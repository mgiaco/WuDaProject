; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\wiegand.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\wiegand.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\RTX\inc -I..\..\RTX\portable -I..\..\User\CpuFlash -I..\..\User\CRC8_16 -I..\..\User\DS1302 -I..\..\User\DWT -I..\..\User\IIC -I..\..\User\IWDG -I..\..\User\Key -I..\..\User\Led -I..\..\User\Net -I..\..\User\Protocal -I..\..\User\Reader -I..\..\User\SPI -I..\..\User\Timer -I..\..\User\Uart -I..\..\User\Param -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\wiegand.crf ..\..\User\Reader\Wiegand.c]
                          THUMB

                          AREA ||i.DataCheck||, CODE, READONLY, ALIGN=1

                  DataCheck PROC
;;;244    **********************************************************/
;;;245    uint8_t DataCheck(SingleReader_T *reader)
000000  b5f0              PUSH     {r4-r7,lr}
;;;246    {
000002  4601              MOV      r1,r0
;;;247        uint8_t i=0;
000004  2200              MOVS     r2,#0
;;;248        uint8_t j=0;
000006  2400              MOVS     r4,#0
;;;249        uint8_t NumsOfOne=0;
000008  2300              MOVS     r3,#0
;;;250        uint8_t len = 26;
00000a  251a              MOVS     r5,#0x1a
;;;251        //偶校验
;;;252        for(i=1; i<13; i++)
00000c  2201              MOVS     r2,#1
00000e  e007              B        |L1.32|
                  |L1.16|
;;;253        {
;;;254            if(reader->buf[i] == 1)
000010  1dc8              ADDS     r0,r1,#7
000012  5c80              LDRB     r0,[r0,r2]
000014  2801              CMP      r0,#1
000016  d101              BNE      |L1.28|
;;;255            {
;;;256                NumsOfOne++;
000018  1c58              ADDS     r0,r3,#1
00001a  b2c3              UXTB     r3,r0
                  |L1.28|
00001c  1c50              ADDS     r0,r2,#1              ;252
00001e  b2c2              UXTB     r2,r0                 ;252
                  |L1.32|
000020  2a0d              CMP      r2,#0xd               ;252
000022  dbf5              BLT      |L1.16|
;;;257            }
;;;258        }
;;;259        if((NumsOfOne%2 == 0) && (reader->buf[0] == 1))
000024  4618              MOV      r0,r3
000026  eb0376d0          ADD      r6,r3,r0,LSR #31
00002a  1076              ASRS     r6,r6,#1
00002c  ebb30646          SUBS     r6,r3,r6,LSL #1
000030  d104              BNE      |L1.60|
000032  79ce              LDRB     r6,[r1,#7]
000034  2e01              CMP      r6,#1
000036  d101              BNE      |L1.60|
;;;260        {
;;;261                return 0;         
000038  2000              MOVS     r0,#0
                  |L1.58|
;;;262        }
;;;263        if((NumsOfOne%2 == 1) && (reader->buf[0] == 0))
;;;264        {
;;;265                return 0;         
;;;266        }
;;;267        //奇校验
;;;268        NumsOfOne = 0;
;;;269        for(i=13; i<25; i++)
;;;270        {
;;;271            if(reader->buf[i] == 1)
;;;272            {
;;;273                NumsOfOne++;
;;;274            }
;;;275        }
;;;276        if((NumsOfOne%2 == 1) && (reader->buf[len-1] == 1))
;;;277        {
;;;278                return 0;         
;;;279        }
;;;280        if((NumsOfOne%2 == 0) && (reader->buf[len-1] == 0))
;;;281        {
;;;282                return 0;         
;;;283        }
;;;284        
;;;285        //计算ID号
;;;286        reader->ID[0] = 0;
;;;287        reader->ID[1] = 0;
;;;288        reader->ID[2] = 0;
;;;289        for(i=1,j=7; i<9; i++,j--)
;;;290        {    
;;;291            reader->ID[0] += reader->buf[i]<<j;
;;;292        }
;;;293        for(i=9,j=7; i<17; i++,j--)
;;;294        {    
;;;295            reader->ID[1] += reader->buf[i]<<j;
;;;296        }
;;;297        for(i=17,j=7; i<25; i++,j--)
;;;298        {    
;;;299            reader->ID[2] += reader->buf[i]<<j;
;;;300        } 
;;;301        DEBUG(COM1, reader->ID, 3);
;;;302        return 1;
;;;303        
;;;304    }
00003a  bdf0              POP      {r4-r7,pc}
                  |L1.60|
00003c  4618              MOV      r0,r3                 ;263
00003e  eb0376d0          ADD      r6,r3,r0,LSR #31      ;263
000042  1076              ASRS     r6,r6,#1              ;263
000044  eba30646          SUB      r6,r3,r6,LSL #1       ;263
000048  2e01              CMP      r6,#1                 ;263
00004a  d103              BNE      |L1.84|
00004c  79ce              LDRB     r6,[r1,#7]            ;263
00004e  b90e              CBNZ     r6,|L1.84|
000050  2000              MOVS     r0,#0                 ;265
000052  e7f2              B        |L1.58|
                  |L1.84|
000054  2300              MOVS     r3,#0                 ;268
000056  220d              MOVS     r2,#0xd               ;269
000058  e007              B        |L1.106|
                  |L1.90|
00005a  1dc8              ADDS     r0,r1,#7              ;271
00005c  5c80              LDRB     r0,[r0,r2]            ;271
00005e  2801              CMP      r0,#1                 ;271
000060  d101              BNE      |L1.102|
000062  1c58              ADDS     r0,r3,#1              ;273
000064  b2c3              UXTB     r3,r0                 ;273
                  |L1.102|
000066  1c50              ADDS     r0,r2,#1              ;269
000068  b2c2              UXTB     r2,r0                 ;269
                  |L1.106|
00006a  2a19              CMP      r2,#0x19              ;269
00006c  dbf5              BLT      |L1.90|
00006e  4618              MOV      r0,r3                 ;276
000070  eb0376d0          ADD      r6,r3,r0,LSR #31      ;276
000074  1076              ASRS     r6,r6,#1              ;276
000076  eba30646          SUB      r6,r3,r6,LSL #1       ;276
00007a  2e01              CMP      r6,#1                 ;276
00007c  d106              BNE      |L1.140|
00007e  1e6e              SUBS     r6,r5,#1              ;276
000080  1dcf              ADDS     r7,r1,#7              ;276
000082  5dbe              LDRB     r6,[r7,r6]            ;276
000084  2e01              CMP      r6,#1                 ;276
000086  d101              BNE      |L1.140|
000088  2000              MOVS     r0,#0                 ;278
00008a  e7d6              B        |L1.58|
                  |L1.140|
00008c  4618              MOV      r0,r3                 ;280
00008e  eb0376d0          ADD      r6,r3,r0,LSR #31      ;280
000092  1076              ASRS     r6,r6,#1              ;280
000094  ebb30646          SUBS     r6,r3,r6,LSL #1       ;280
000098  d105              BNE      |L1.166|
00009a  1e6e              SUBS     r6,r5,#1              ;280
00009c  1dcf              ADDS     r7,r1,#7              ;280
00009e  5dbe              LDRB     r6,[r7,r6]            ;280
0000a0  b90e              CBNZ     r6,|L1.166|
0000a2  2000              MOVS     r0,#0                 ;282
0000a4  e7c9              B        |L1.58|
                  |L1.166|
0000a6  2000              MOVS     r0,#0                 ;286
0000a8  7108              STRB     r0,[r1,#4]            ;286
0000aa  2600              MOVS     r6,#0                 ;287
0000ac  714e              STRB     r6,[r1,#5]            ;287
0000ae  718e              STRB     r6,[r1,#6]            ;288
0000b0  2201              MOVS     r2,#1                 ;289
0000b2  2407              MOVS     r4,#7                 ;289
0000b4  e009              B        |L1.202|
                  |L1.182|
0000b6  790e              LDRB     r6,[r1,#4]            ;291
0000b8  1dc8              ADDS     r0,r1,#7              ;291
0000ba  5c80              LDRB     r0,[r0,r2]            ;291
0000bc  40a0              LSLS     r0,r0,r4              ;291
0000be  4430              ADD      r0,r0,r6              ;291
0000c0  7108              STRB     r0,[r1,#4]            ;291
0000c2  1c50              ADDS     r0,r2,#1              ;289
0000c4  b2c2              UXTB     r2,r0                 ;289
0000c6  1e60              SUBS     r0,r4,#1              ;289
0000c8  b2c4              UXTB     r4,r0                 ;289
                  |L1.202|
0000ca  2a09              CMP      r2,#9                 ;289
0000cc  dbf3              BLT      |L1.182|
0000ce  2209              MOVS     r2,#9                 ;293
0000d0  2407              MOVS     r4,#7                 ;293
0000d2  e009              B        |L1.232|
                  |L1.212|
0000d4  794e              LDRB     r6,[r1,#5]            ;295
0000d6  1dc8              ADDS     r0,r1,#7              ;295
0000d8  5c80              LDRB     r0,[r0,r2]            ;295
0000da  40a0              LSLS     r0,r0,r4              ;295
0000dc  4430              ADD      r0,r0,r6              ;295
0000de  7148              STRB     r0,[r1,#5]            ;295
0000e0  1c50              ADDS     r0,r2,#1              ;293
0000e2  b2c2              UXTB     r2,r0                 ;293
0000e4  1e60              SUBS     r0,r4,#1              ;293
0000e6  b2c4              UXTB     r4,r0                 ;293
                  |L1.232|
0000e8  2a11              CMP      r2,#0x11              ;293
0000ea  dbf3              BLT      |L1.212|
0000ec  2211              MOVS     r2,#0x11              ;297
0000ee  2407              MOVS     r4,#7                 ;297
0000f0  e009              B        |L1.262|
                  |L1.242|
0000f2  798e              LDRB     r6,[r1,#6]            ;299
0000f4  1dc8              ADDS     r0,r1,#7              ;299
0000f6  5c80              LDRB     r0,[r0,r2]            ;299
0000f8  40a0              LSLS     r0,r0,r4              ;299
0000fa  4430              ADD      r0,r0,r6              ;299
0000fc  7188              STRB     r0,[r1,#6]            ;299
0000fe  1c50              ADDS     r0,r2,#1              ;297
000100  b2c2              UXTB     r2,r0                 ;297
000102  1e60              SUBS     r0,r4,#1              ;297
000104  b2c4              UXTB     r4,r0                 ;297
                  |L1.262|
000106  2a19              CMP      r2,#0x19              ;297
000108  dbf3              BLT      |L1.242|
00010a  2001              MOVS     r0,#1                 ;302
00010c  e795              B        |L1.58|
;;;305    
                          ENDP


                          AREA ||i.DetectReader||, CODE, READONLY, ALIGN=2

                  DetectReader PROC
;;;338    //检测读头是否连接
;;;339    void DetectReader(void)
000000  b510              PUSH     {r4,lr}
;;;340    {
;;;341        if((GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0) == 1)\
000002  2101              MOVS     r1,#1
000004  4813              LDR      r0,|L2.84|
000006  f7fffffe          BL       GPIO_ReadInputDataBit
00000a  2801              CMP      r0,#1
00000c  d108              BNE      |L2.32|
;;;342            && (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_1) == 1))//读取readerA
00000e  2102              MOVS     r1,#2
000010  4810              LDR      r0,|L2.84|
000012  f7fffffe          BL       GPIO_ReadInputDataBit
000016  2801              CMP      r0,#1
000018  d102              BNE      |L2.32|
;;;343        {
;;;344            g_tReader.readerA.status = 1;
00001a  490f              LDR      r1,|L2.88|
00001c  7048              STRB     r0,[r1,#1]
00001e  e002              B        |L2.38|
                  |L2.32|
;;;345        }
;;;346        else g_tReader.readerA.status = 0;
000020  2000              MOVS     r0,#0
000022  490d              LDR      r1,|L2.88|
000024  7048              STRB     r0,[r1,#1]
                  |L2.38|
;;;347        
;;;348        if((GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_2) == 1)\
000026  2104              MOVS     r1,#4
000028  480a              LDR      r0,|L2.84|
00002a  f7fffffe          BL       GPIO_ReadInputDataBit
00002e  2801              CMP      r0,#1
000030  d10a              BNE      |L2.72|
;;;349            && (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_3) == 1))//读取readerB
000032  2108              MOVS     r1,#8
000034  4807              LDR      r0,|L2.84|
000036  f7fffffe          BL       GPIO_ReadInputDataBit
00003a  2801              CMP      r0,#1
00003c  d104              BNE      |L2.72|
;;;350        {
;;;351            g_tReader.readerB.status = 1;
00003e  2101              MOVS     r1,#1
000040  4805              LDR      r0,|L2.88|
000042  f8801022          STRB     r1,[r0,#0x22]
000046  e003              B        |L2.80|
                  |L2.72|
;;;352        }
;;;353        else g_tReader.readerB.status = 0;
000048  2100              MOVS     r1,#0
00004a  4803              LDR      r0,|L2.88|
00004c  f8801022          STRB     r1,[r0,#0x22]
                  |L2.80|
;;;354    }
000050  bd10              POP      {r4,pc}
;;;355    
                          ENDP

000052  0000              DCW      0x0000
                  |L2.84|
                          DCD      0x40010800
                  |L2.88|
                          DCD      g_tReader

                          AREA ||i.EXTI0_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI0_IRQHandler PROC
;;;115    //读头A的data0//1pps中断
;;;116    void EXTI0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;117    {
;;;118    	if (EXTI_GetITStatus(EXTI_Line0) != RESET)
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       EXTI_GetITStatus
000008  b140              CBZ      r0,|L3.28|
;;;119    	{
;;;120    		//Data0	-> 低电平表示1位0
;;;121    //        if(g_tReader.readerA.isDelayTimerOpen == FALSE)
;;;122    //        {
;;;123    //            OpenWiegandDelayTimerA();
;;;124    //        }
;;;125    //        
;;;126    //        g_tReader.readerA.buf[g_tReader.readerA.writeIndex++] = 0;
;;;127    //        if(g_tReader.readerA.writeIndex == 26)
;;;128    //        {
;;;129    //            g_tReader.readerA.writeIndex = 0;
;;;130    //            
;;;131    //            /* 如果消息邮箱还有空间，向消息邮箱发送数据 */
;;;132    //            if (isr_mbx_check (&mailboxCardRX) != 0)
;;;133    //            {
;;;134    //                isr_mbx_send(&mailboxCardRX, &g_tReader.readerA);		
;;;135    //            }
;;;136    //            //发送任务事件标志
;;;137    //            //isr_evt_set(READER_A_BIT, HandleTaskDoor);
;;;138    //        }
;;;139    		
;;;140            g_tDetector.tStart = DWT_CYCCNT;
00000a  4805              LDR      r0,|L3.32|
00000c  6840              LDR      r0,[r0,#4]
00000e  4905              LDR      r1,|L3.36|
000010  6088              STR      r0,[r1,#8]  ; g_tDetector
;;;141            g_tDetector.tStop = 0;
000012  2000              MOVS     r0,#0
000014  60c8              STR      r0,[r1,#0xc]  ; g_tDetector
;;;142            
;;;143    		EXTI_ClearITPendingBit(EXTI_Line0);	
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       EXTI_ClearITPendingBit
                  |L3.28|
;;;144    	}
;;;145    }
00001c  bd10              POP      {r4,pc}
;;;146    
                          ENDP

00001e  0000              DCW      0x0000
                  |L3.32|
                          DCD      0xe0001000
                  |L3.36|
                          DCD      g_tDetector

                          AREA ||i.EXTI1_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI1_IRQHandler PROC
;;;148    //读头A的data1//光电探测器中断
;;;149    void EXTI1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;150    {
;;;151    	if (EXTI_GetITStatus(EXTI_Line1) != RESET)
000002  2002              MOVS     r0,#2
000004  f7fffffe          BL       EXTI_GetITStatus
000008  b1e8              CBZ      r0,|L4.70|
;;;152    	{
;;;153    		//Data1 -> 低电平表示1位1
;;;154    //        if(g_tReader.readerA.isDelayTimerOpen == FALSE)
;;;155    //        {
;;;156    //            OpenWiegandDelayTimerA();
;;;157    //        }
;;;158    //        
;;;159    //        g_tReader.readerA.buf[g_tReader.readerA.writeIndex++] = 1;
;;;160    //        if(g_tReader.readerA.writeIndex == 26)
;;;161    //        {
;;;162    //            g_tReader.readerA.writeIndex = 0;           
;;;163    //            
;;;164    //            /* 如果消息邮箱还有空间，向消息邮箱发送数据 */
;;;165    //            if (isr_mbx_check (&mailboxCardRX) != 0)
;;;166    //            {
;;;167    //                isr_mbx_send(&mailboxCardRX, &g_tReader.readerA);		
;;;168    //            }
;;;169    //            //发送任务事件标志
;;;170    //            //isr_evt_set(READER_A_BIT, HandleTaskDoor);
;;;171    //        }
;;;172    		g_tDetector.tStop = DWT_CYCCNT;
00000a  480f              LDR      r0,|L4.72|
00000c  6840              LDR      r0,[r0,#4]
00000e  490f              LDR      r1,|L4.76|
000010  60c8              STR      r0,[r1,#0xc]  ; g_tDetector
;;;173            dwtTime = (g_tDetector.tStop - g_tDetector.tStart)/72;
000012  4608              MOV      r0,r1
000014  68c0              LDR      r0,[r0,#0xc]  ; g_tDetector
000016  6889              LDR      r1,[r1,#8]  ; g_tDetector
000018  1a40              SUBS     r0,r0,r1
00001a  2148              MOVS     r1,#0x48
00001c  fbb0f0f1          UDIV     r0,r0,r1
000020  490b              LDR      r1,|L4.80|
000022  6008              STR      r0,[r1,#0]  ; dwtTime
;;;174                    g_tDetector.preciseSingleTime[2] = dwtTime&0xFF;
000024  4608              MOV      r0,r1
000026  7801              LDRB     r1,[r0,#0]  ; dwtTime
000028  4808              LDR      r0,|L4.76|
00002a  7481              STRB     r1,[r0,#0x12]
;;;175                    g_tDetector.preciseSingleTime[1] = (dwtTime>>8)&0xFF;
00002c  4808              LDR      r0,|L4.80|
00002e  8800              LDRH     r0,[r0,#0]  ; dwtTime
000030  0a01              LSRS     r1,r0,#8
000032  4806              LDR      r0,|L4.76|
000034  7441              STRB     r1,[r0,#0x11]
;;;176                    g_tDetector.preciseSingleTime[0] = dwtTime>>16;
000036  4806              LDR      r0,|L4.80|
000038  6800              LDR      r0,[r0,#0]  ; dwtTime
00003a  0c00              LSRS     r0,r0,#16
00003c  4903              LDR      r1,|L4.76|
00003e  7408              STRB     r0,[r1,#0x10]
;;;177    		EXTI_ClearITPendingBit(EXTI_Line1);
000040  2002              MOVS     r0,#2
000042  f7fffffe          BL       EXTI_ClearITPendingBit
                  |L4.70|
;;;178    	}
;;;179    }
000046  bd10              POP      {r4,pc}
;;;180    
                          ENDP

                  |L4.72|
                          DCD      0xe0001000
                  |L4.76|
                          DCD      g_tDetector
                  |L4.80|
                          DCD      dwtTime

                          AREA ||i.EXTI2_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI2_IRQHandler PROC
;;;181    //读头B的data0
;;;182    void EXTI2_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;183    {
;;;184    	if (EXTI_GetITStatus(EXTI_Line2) != RESET)
000002  2004              MOVS     r0,#4
000004  f7fffffe          BL       EXTI_GetITStatus
000008  b328              CBZ      r0,|L5.86|
;;;185    	{
;;;186    		//Data0	-> 低电平表示1位0
;;;187            if(g_tReader.readerB.isDelayTimerOpen == FALSE)
00000a  4813              LDR      r0,|L5.88|
00000c  f8900024          LDRB     r0,[r0,#0x24]
000010  b908              CBNZ     r0,|L5.22|
;;;188            {
;;;189                OpenWiegandDelayTimerB();
000012  f7fffffe          BL       OpenWiegandDelayTimerB
                  |L5.22|
;;;190            }
;;;191            
;;;192            g_tReader.readerB.buf[g_tReader.readerB.writeIndex++] = 0;
000016  2200              MOVS     r2,#0
000018  490f              LDR      r1,|L5.88|
00001a  f8910023          LDRB     r0,[r1,#0x23]
00001e  1c41              ADDS     r1,r0,#1
000020  b2cb              UXTB     r3,r1
000022  490d              LDR      r1,|L5.88|
000024  f8813023          STRB     r3,[r1,#0x23]
000028  3128              ADDS     r1,r1,#0x28
00002a  540a              STRB     r2,[r1,r0]
;;;193            if(g_tReader.readerB.writeIndex == 26)
00002c  480a              LDR      r0,|L5.88|
00002e  f8900023          LDRB     r0,[r0,#0x23]
000032  281a              CMP      r0,#0x1a
000034  d10c              BNE      |L5.80|
;;;194            {
;;;195                g_tReader.readerB.writeIndex = 0;
000036  2100              MOVS     r1,#0
000038  4807              LDR      r0,|L5.88|
00003a  f8801023          STRB     r1,[r0,#0x23]
;;;196                
;;;197                /* 如果消息邮箱还有空间，向消息邮箱发送数据 */
;;;198                if (isr_mbx_check (&mailboxCardRX) != 0)
00003e  4807              LDR      r0,|L5.92|
000040  f7fffffe          BL       rt_mbx_check
000044  b120              CBZ      r0,|L5.80|
;;;199                {
;;;200                    isr_mbx_send(&mailboxCardRX, &g_tReader.readerB);		
000046  4904              LDR      r1,|L5.88|
000048  3121              ADDS     r1,r1,#0x21
00004a  4804              LDR      r0,|L5.92|
00004c  f7fffffe          BL       isr_mbx_send
                  |L5.80|
;;;201                }
;;;202                //发送任务事件标志
;;;203                //isr_evt_set(READER_B_BIT, HandleTaskDoor);
;;;204            }
;;;205    		
;;;206    		EXTI_ClearITPendingBit(EXTI_Line2);	
000050  2004              MOVS     r0,#4
000052  f7fffffe          BL       EXTI_ClearITPendingBit
                  |L5.86|
;;;207    	}
;;;208    }
000056  bd10              POP      {r4,pc}
;;;209    
                          ENDP

                  |L5.88|
                          DCD      g_tReader
                  |L5.92|
                          DCD      mailboxCardRX

                          AREA ||i.EXTI3_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI3_IRQHandler PROC
;;;210    //读头B的data1
;;;211    void EXTI3_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;212    {
;;;213    	if (EXTI_GetITStatus(EXTI_Line3) != RESET)
000002  2008              MOVS     r0,#8
000004  f7fffffe          BL       EXTI_GetITStatus
000008  b328              CBZ      r0,|L6.86|
;;;214    	{
;;;215    		//Data1 -> 低电平表示1位1
;;;216            if(g_tReader.readerB.isDelayTimerOpen == FALSE)
00000a  4813              LDR      r0,|L6.88|
00000c  f8900024          LDRB     r0,[r0,#0x24]
000010  b908              CBNZ     r0,|L6.22|
;;;217            {
;;;218                OpenWiegandDelayTimerB();
000012  f7fffffe          BL       OpenWiegandDelayTimerB
                  |L6.22|
;;;219            }
;;;220            
;;;221            g_tReader.readerB.buf[g_tReader.readerB.writeIndex++] = 1;
000016  2201              MOVS     r2,#1
000018  490f              LDR      r1,|L6.88|
00001a  f8910023          LDRB     r0,[r1,#0x23]
00001e  1c41              ADDS     r1,r0,#1
000020  b2cb              UXTB     r3,r1
000022  490d              LDR      r1,|L6.88|
000024  f8813023          STRB     r3,[r1,#0x23]
000028  3128              ADDS     r1,r1,#0x28
00002a  540a              STRB     r2,[r1,r0]
;;;222            if(g_tReader.readerB.writeIndex == 26)
00002c  480a              LDR      r0,|L6.88|
00002e  f8900023          LDRB     r0,[r0,#0x23]
000032  281a              CMP      r0,#0x1a
000034  d10c              BNE      |L6.80|
;;;223            {
;;;224                g_tReader.readerB.writeIndex = 0;            
000036  2100              MOVS     r1,#0
000038  4807              LDR      r0,|L6.88|
00003a  f8801023          STRB     r1,[r0,#0x23]
;;;225                
;;;226                /* 如果消息邮箱还有空间，向消息邮箱发送数据 */
;;;227                if (isr_mbx_check (&mailboxCardRX) != 0)
00003e  4807              LDR      r0,|L6.92|
000040  f7fffffe          BL       rt_mbx_check
000044  b120              CBZ      r0,|L6.80|
;;;228                {
;;;229                    isr_mbx_send(&mailboxCardRX, &g_tReader.readerB);		
000046  4904              LDR      r1,|L6.88|
000048  3121              ADDS     r1,r1,#0x21
00004a  4804              LDR      r0,|L6.92|
00004c  f7fffffe          BL       isr_mbx_send
                  |L6.80|
;;;230                }
;;;231                //发送任务事件标志
;;;232                //isr_evt_set(READER_B_BIT, HandleTaskDoor);
;;;233            }
;;;234    		
;;;235    		EXTI_ClearITPendingBit(EXTI_Line3);
000050  2008              MOVS     r0,#8
000052  f7fffffe          BL       EXTI_ClearITPendingBit
                  |L6.86|
;;;236    	}
;;;237    }
000056  bd10              POP      {r4,pc}
;;;238    
                          ENDP

                  |L6.88|
                          DCD      g_tReader
                  |L6.92|
                          DCD      mailboxCardRX

                          AREA ||i.HandlDelayTimerA||, CODE, READONLY, ALIGN=2

                  HandlDelayTimerA PROC
;;;325    
;;;326    static void HandlDelayTimerA(void)
000000  2000              MOVS     r0,#0
;;;327    {   
;;;328        g_tReader.readerA.isDelayTimerOpen = 0;
000002  4902              LDR      r1,|L7.12|
000004  70c8              STRB     r0,[r1,#3]
;;;329        g_tReader.readerA.writeIndex = 0;
000006  7088              STRB     r0,[r1,#2]
;;;330    }
000008  4770              BX       lr
;;;331    
                          ENDP

00000a  0000              DCW      0x0000
                  |L7.12|
                          DCD      g_tReader

                          AREA ||i.HandlDelayTimerB||, CODE, READONLY, ALIGN=2

                  HandlDelayTimerB PROC
;;;331    
;;;332    static void HandlDelayTimerB(void)
000000  2100              MOVS     r1,#0
;;;333    {   
;;;334        g_tReader.readerB.isDelayTimerOpen = 0;
000002  4803              LDR      r0,|L8.16|
000004  f8801024          STRB     r1,[r0,#0x24]
;;;335        g_tReader.readerB.writeIndex = 0;
000008  f8801023          STRB     r1,[r0,#0x23]
;;;336    }
00000c  4770              BX       lr
;;;337    
                          ENDP

00000e  0000              DCW      0x0000
                  |L8.16|
                          DCD      g_tReader

                          AREA ||i.OpenWiegandDelayTimerA||, CODE, READONLY, ALIGN=2

                  OpenWiegandDelayTimerA PROC
;;;306    //打开韦根信号A超时定时器,TIM2定时器通道1
;;;307    static void OpenWiegandDelayTimerA(void)
000000  b510              PUSH     {r4,lr}
;;;308    {
;;;309        if(g_tReader.readerA.isDelayTimerOpen == 0)
000002  4805              LDR      r0,|L9.24|
000004  78c0              LDRB     r0,[r0,#3]  ; g_tReader
000006  b930              CBNZ     r0,|L9.22|
;;;310        {
;;;311            g_tReader.readerA.isDelayTimerOpen = 1;
000008  2001              MOVS     r0,#1
00000a  4903              LDR      r1,|L9.24|
00000c  70c8              STRB     r0,[r1,#3]
;;;312            bsp_StartHardTimer(1, 200, (void *)HandlDelayTimerA);
00000e  4a03              LDR      r2,|L9.28|
000010  21c8              MOVS     r1,#0xc8
000012  f7fffffe          BL       bsp_StartHardTimer
                  |L9.22|
;;;313        }
;;;314    }
000016  bd10              POP      {r4,pc}
;;;315    
                          ENDP

                  |L9.24|
                          DCD      g_tReader
                  |L9.28|
                          DCD      HandlDelayTimerA

                          AREA ||i.OpenWiegandDelayTimerB||, CODE, READONLY, ALIGN=2

                  OpenWiegandDelayTimerB PROC
;;;316    //打开韦根信号B超时定时器,TIM2定时器通道2
;;;317    static void OpenWiegandDelayTimerB(void)
000000  b510              PUSH     {r4,lr}
;;;318    {
;;;319        if(g_tReader.readerB.isDelayTimerOpen == 0)
000002  4807              LDR      r0,|L10.32|
000004  f8900024          LDRB     r0,[r0,#0x24]
000008  b940              CBNZ     r0,|L10.28|
;;;320        {
;;;321            g_tReader.readerB.isDelayTimerOpen = 1;
00000a  2101              MOVS     r1,#1
00000c  4804              LDR      r0,|L10.32|
00000e  f8801024          STRB     r1,[r0,#0x24]
;;;322            bsp_StartHardTimer(2, 200, (void *)HandlDelayTimerB);
000012  4a04              LDR      r2,|L10.36|
000014  21c8              MOVS     r1,#0xc8
000016  2002              MOVS     r0,#2
000018  f7fffffe          BL       bsp_StartHardTimer
                  |L10.28|
;;;323        }
;;;324    }
00001c  bd10              POP      {r4,pc}
;;;325    
                          ENDP

00001e  0000              DCW      0x0000
                  |L10.32|
                          DCD      g_tReader
                  |L10.36|
                          DCD      HandlDelayTimerB

                          AREA ||i.WiegandInit||, CODE, READONLY, ALIGN=2

                  WiegandInit PROC
;;;20     **********************************************************/
;;;21     void WiegandInit(void)
000000  b51f              PUSH     {r0-r4,lr}
;;;22     {
;;;23         GPIO_InitTypeDef GPIO_InitStructure;
;;;24     	EXTI_InitTypeDef EXTI_InitStructure;
;;;25     	NVIC_InitTypeDef NVIC_InitStructure;
;;;26         
;;;27         g_tReader.readerA.readerID = e_READER_A;
000002  2000              MOVS     r0,#0
000004  4953              LDR      r1,|L11.340|
000006  7008              STRB     r0,[r1,#0]
;;;28         g_tReader.readerA.writeIndex = 0;
000008  7088              STRB     r0,[r1,#2]
;;;29         g_tReader.readerA.isDelayTimerOpen = 0;
00000a  70c8              STRB     r0,[r1,#3]
;;;30         
;;;31         g_tReader.readerB.readerID = e_READER_B;
00000c  2001              MOVS     r0,#1
00000e  f8810021          STRB     r0,[r1,#0x21]
;;;32         g_tReader.readerB.writeIndex = 0;
000012  2100              MOVS     r1,#0
000014  484f              LDR      r0,|L11.340|
000016  f8801023          STRB     r1,[r0,#0x23]
;;;33         g_tReader.readerB.isDelayTimerOpen = 0;
00001a  f8801024          STRB     r1,[r0,#0x24]
;;;34         
;;;35         g_tReader.dataCheck = DataCheck;
00001e  484e              LDR      r0,|L11.344|
000020  494c              LDR      r1,|L11.340|
000022  6448              STR      r0,[r1,#0x44]  ; g_tReader
;;;36         
;;;37         DetectReader();
000024  f7fffffe          BL       DetectReader
;;;38         
;;;39     	//韦根信号线 PA0,1,2,3
;;;40     	/* 使能 GPIO 时钟 */
;;;41     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);
000028  2101              MOVS     r1,#1
00002a  2004              MOVS     r0,#4
00002c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;42     	
;;;43     	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_0 | GPIO_Pin_1 |GPIO_Pin_2 | GPIO_Pin_3;
000030  200f              MOVS     r0,#0xf
000032  f8ad000c          STRH     r0,[sp,#0xc]
;;;44     	//GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;	  	//上拉输入
;;;45         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//输入浮空模式
000036  2004              MOVS     r0,#4
000038  f88d000f          STRB     r0,[sp,#0xf]
;;;46     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00003c  2003              MOVS     r0,#3
00003e  f88d000e          STRB     r0,[sp,#0xe]
;;;47     	GPIO_Init(GPIOA, &GPIO_InitStructure);
000042  a903              ADD      r1,sp,#0xc
000044  4845              LDR      r0,|L11.348|
000046  f7fffffe          BL       GPIO_Init
;;;48     	/* 使能 AFIO 时钟 */
;;;49     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
00004a  2101              MOVS     r1,#1
00004c  4608              MOV      r0,r1
00004e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;50     	//读头A
;;;51         //Data0 中断线	PA0
;;;52     	GPIO_EXTILineConfig(GPIO_PortSourceGPIOA,GPIO_PinSource0); 
000052  2100              MOVS     r1,#0
000054  4608              MOV      r0,r1
000056  f7fffffe          BL       GPIO_EXTILineConfig
;;;53     	EXTI_InitStructure.EXTI_Line	= EXTI_Line0;
00005a  2001              MOVS     r0,#1
00005c  9001              STR      r0,[sp,#4]
;;;54     	EXTI_InitStructure.EXTI_Mode 	= EXTI_Mode_Interrupt;	
00005e  2000              MOVS     r0,#0
000060  f88d0008          STRB     r0,[sp,#8]
;;;55     	//EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;	//下降沿触发
;;;56         EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;//上升沿触发
000064  2008              MOVS     r0,#8
000066  f88d0009          STRB     r0,[sp,#9]
;;;57     	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
00006a  2001              MOVS     r0,#1
00006c  f88d000a          STRB     r0,[sp,#0xa]
;;;58     	EXTI_Init(&EXTI_InitStructure);	 
000070  a801              ADD      r0,sp,#4
000072  f7fffffe          BL       EXTI_Init
;;;59     	
;;;60     	//中断优先级，尽可能设为最高优先级
;;;61     	NVIC_InitStructure.NVIC_IRQChannel 	= EXTI0_IRQn;//使能按键所在的外部中断通道
000076  2006              MOVS     r0,#6
000078  f88d0000          STRB     r0,[sp,#0]
;;;62     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;//抢占优先级 
00007c  2000              MOVS     r0,#0
00007e  f88d0001          STRB     r0,[sp,#1]
;;;63     	NVIC_InitStructure.NVIC_IRQChannelSubPriority 	= 0x00;//子优先级
000082  f88d0002          STRB     r0,[sp,#2]
;;;64     	NVIC_InitStructure.NVIC_IRQChannelCmd 	= ENABLE;//使能外部中断通道
000086  2001              MOVS     r0,#1
000088  f88d0003          STRB     r0,[sp,#3]
;;;65     	NVIC_Init(&NVIC_InitStructure); 
00008c  4668              MOV      r0,sp
00008e  f7fffffe          BL       NVIC_Init
;;;66     	
;;;67     	//Data1 中断线  PA1
;;;68     	GPIO_EXTILineConfig(GPIO_PortSourceGPIOA,GPIO_PinSource1);
000092  2101              MOVS     r1,#1
000094  2000              MOVS     r0,#0
000096  f7fffffe          BL       GPIO_EXTILineConfig
;;;69     	EXTI_InitStructure.EXTI_Line	= EXTI_Line1;
00009a  2002              MOVS     r0,#2
00009c  9001              STR      r0,[sp,#4]
;;;70     	EXTI_InitStructure.EXTI_Mode 	= EXTI_Mode_Interrupt;	
00009e  2000              MOVS     r0,#0
0000a0  f88d0008          STRB     r0,[sp,#8]
;;;71     	//EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;	  	//下降沿触发
;;;72         EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;//上升沿触发
0000a4  2008              MOVS     r0,#8
0000a6  f88d0009          STRB     r0,[sp,#9]
;;;73     	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
0000aa  2001              MOVS     r0,#1
0000ac  f88d000a          STRB     r0,[sp,#0xa]
;;;74     	EXTI_Init(&EXTI_InitStructure);	
0000b0  a801              ADD      r0,sp,#4
0000b2  f7fffffe          BL       EXTI_Init
;;;75     	
;;;76     	//中断优先级，尽可能设为最高优先级
;;;77     	NVIC_InitStructure.NVIC_IRQChannel 	= EXTI1_IRQn;	//使能按键所在的外部中断通道
0000b6  2007              MOVS     r0,#7
0000b8  f88d0000          STRB     r0,[sp,#0]
;;;78     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;	//抢占优先级 
0000bc  2000              MOVS     r0,#0
0000be  f88d0001          STRB     r0,[sp,#1]
;;;79     	NVIC_InitStructure.NVIC_IRQChannelSubPriority 	= 0x00;	//子优先级
0000c2  f88d0002          STRB     r0,[sp,#2]
;;;80     	NVIC_InitStructure.NVIC_IRQChannelCmd 	= ENABLE;	//使能外部中断通道
0000c6  2001              MOVS     r0,#1
0000c8  f88d0003          STRB     r0,[sp,#3]
;;;81     	NVIC_Init(&NVIC_InitStructure); 
0000cc  4668              MOV      r0,sp
0000ce  f7fffffe          BL       NVIC_Init
;;;82         
;;;83         //读头B
;;;84         //Data0 中断线	PA2
;;;85     	GPIO_EXTILineConfig(GPIO_PortSourceGPIOA,GPIO_PinSource2); 
0000d2  2102              MOVS     r1,#2
0000d4  2000              MOVS     r0,#0
0000d6  f7fffffe          BL       GPIO_EXTILineConfig
;;;86     	EXTI_InitStructure.EXTI_Line	= EXTI_Line2;
0000da  2004              MOVS     r0,#4
0000dc  9001              STR      r0,[sp,#4]
;;;87     	EXTI_InitStructure.EXTI_Mode 	= EXTI_Mode_Interrupt;	
0000de  2000              MOVS     r0,#0
0000e0  f88d0008          STRB     r0,[sp,#8]
;;;88     	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;	//下降沿触发
0000e4  200c              MOVS     r0,#0xc
0000e6  f88d0009          STRB     r0,[sp,#9]
;;;89     	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
0000ea  2001              MOVS     r0,#1
0000ec  f88d000a          STRB     r0,[sp,#0xa]
;;;90     	EXTI_Init(&EXTI_InitStructure);	 
0000f0  a801              ADD      r0,sp,#4
0000f2  f7fffffe          BL       EXTI_Init
;;;91     	
;;;92     	//中断优先级，尽可能设为最高优先级
;;;93     	NVIC_InitStructure.NVIC_IRQChannel 	= EXTI2_IRQn;//使能按键所在的外部中断通道
0000f6  2008              MOVS     r0,#8
0000f8  f88d0000          STRB     r0,[sp,#0]
;;;94     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;//抢占优先级 
0000fc  2000              MOVS     r0,#0
0000fe  f88d0001          STRB     r0,[sp,#1]
;;;95     	NVIC_InitStructure.NVIC_IRQChannelSubPriority 	= 0x00;//子优先级
000102  f88d0002          STRB     r0,[sp,#2]
;;;96     	NVIC_InitStructure.NVIC_IRQChannelCmd 	= ENABLE;//使能外部中断通道
000106  2001              MOVS     r0,#1
000108  f88d0003          STRB     r0,[sp,#3]
;;;97     	NVIC_Init(&NVIC_InitStructure); 
00010c  4668              MOV      r0,sp
00010e  f7fffffe          BL       NVIC_Init
;;;98     	
;;;99     	//Data1 中断线  PA3
;;;100    	GPIO_EXTILineConfig(GPIO_PortSourceGPIOA,GPIO_PinSource3);
000112  2103              MOVS     r1,#3
000114  2000              MOVS     r0,#0
000116  f7fffffe          BL       GPIO_EXTILineConfig
;;;101    	EXTI_InitStructure.EXTI_Line	= EXTI_Line3;
00011a  2008              MOVS     r0,#8
00011c  9001              STR      r0,[sp,#4]
;;;102    	EXTI_InitStructure.EXTI_Mode 	= EXTI_Mode_Interrupt;	
00011e  2000              MOVS     r0,#0
000120  f88d0008          STRB     r0,[sp,#8]
;;;103    	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;	  	//下降沿触发
000124  200c              MOVS     r0,#0xc
000126  f88d0009          STRB     r0,[sp,#9]
;;;104    	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
00012a  2001              MOVS     r0,#1
00012c  f88d000a          STRB     r0,[sp,#0xa]
;;;105    	EXTI_Init(&EXTI_InitStructure);	
000130  a801              ADD      r0,sp,#4
000132  f7fffffe          BL       EXTI_Init
;;;106    	
;;;107    	//中断优先级，尽可能设为最高优先级
;;;108    	NVIC_InitStructure.NVIC_IRQChannel 	= EXTI3_IRQn;	//使能按键所在的外部中断通道
000136  2009              MOVS     r0,#9
000138  f88d0000          STRB     r0,[sp,#0]
;;;109    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;	//抢占优先级 
00013c  2000              MOVS     r0,#0
00013e  f88d0001          STRB     r0,[sp,#1]
;;;110    	NVIC_InitStructure.NVIC_IRQChannelSubPriority 	= 0x00;	//子优先级
000142  f88d0002          STRB     r0,[sp,#2]
;;;111    	NVIC_InitStructure.NVIC_IRQChannelCmd 	= ENABLE;	//使能外部中断通道
000146  2001              MOVS     r0,#1
000148  f88d0003          STRB     r0,[sp,#3]
;;;112    	NVIC_Init(&NVIC_InitStructure); 
00014c  4668              MOV      r0,sp
00014e  f7fffffe          BL       NVIC_Init
;;;113    }
000152  bd1f              POP      {r0-r4,pc}
;;;114    
                          ENDP

                  |L11.340|
                          DCD      g_tReader
                  |L11.344|
                          DCD      DataCheck
                  |L11.348|
                          DCD      0x40010800

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_tReader
                          %        72
                  g_tDetector
                          %        28

                          AREA ||.data||, DATA, ALIGN=2

                  dwtTime
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\Reader\\Wiegand.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_Wiegand_c_efa55718____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_Wiegand_c_efa55718____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_Wiegand_c_efa55718____REVSH|
#line 128
|__asm___9_Wiegand_c_efa55718____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
