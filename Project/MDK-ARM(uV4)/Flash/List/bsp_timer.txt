; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_timer.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_timer.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\RTX\inc -I..\..\RTX\portable -I..\..\User\CpuFlash -I..\..\User\CRC8_16 -I..\..\User\DS1302 -I..\..\User\DWT -I..\..\User\IIC -I..\..\User\IWDG -I..\..\User\Key -I..\..\User\Led -I..\..\User\Net -I..\..\User\Protocal -I..\..\User\Reader -I..\..\User\SPI -I..\..\User\Timer -I..\..\User\Uart -I..\..\User\Param -I..\..\User\ADC -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_timer.crf ..\..\User\Timer\bsp_timer.c]
                          THUMB

                          AREA ||i.TIM2_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM2_IRQHandler PROC
;;;617    #ifdef USE_TIM2
;;;618    void TIM2_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;619    #endif
;;;620    
;;;621    #ifdef USE_TIM3
;;;622    void TIM3_IRQHandler(void)
;;;623    #endif
;;;624    
;;;625    #ifdef USE_TIM4
;;;626    void TIM4_IRQHandler(void)
;;;627    #endif
;;;628    
;;;629    #ifdef USE_TIM5
;;;630    void TIM5_IRQHandler(void)
;;;631    #endif
;;;632    {
;;;633        if (TIM_GetITStatus(TIM_HARD, TIM_IT_CC1))
000002  2102              MOVS     r1,#2
000004  0748              LSLS     r0,r1,#29
000006  f7fffffe          BL       TIM_GetITStatus
00000a  b158              CBZ      r0,|L1.36|
;;;634        {
;;;635            TIM_ClearITPendingBit(TIM_HARD, TIM_IT_CC1);
00000c  2102              MOVS     r1,#2
00000e  0748              LSLS     r0,r1,#29
000010  f7fffffe          BL       TIM_ClearITPendingBit
;;;636            TIM_ITConfig(TIM_HARD, TIM_IT_CC1, DISABLE);	/* 禁能CC1中断 */
000014  2200              MOVS     r2,#0
000016  2102              MOVS     r1,#2
000018  0748              LSLS     r0,r1,#29
00001a  f7fffffe          BL       TIM_ITConfig
;;;637    
;;;638            /* 先关闭中断，再执行回调函数。因为回调函数可能需要重启定时器 */
;;;639            s_TIM_CallBack1();
00001e  481b              LDR      r0,|L1.140|
000020  6800              LDR      r0,[r0,#0]  ; s_TIM_CallBack1
000022  4780              BLX      r0
                  |L1.36|
;;;640        }
;;;641    
;;;642        if (TIM_GetITStatus(TIM_HARD, TIM_IT_CC2))
000024  2104              MOVS     r1,#4
000026  0708              LSLS     r0,r1,#28
000028  f7fffffe          BL       TIM_GetITStatus
00002c  b158              CBZ      r0,|L1.70|
;;;643        {
;;;644            TIM_ClearITPendingBit(TIM_HARD, TIM_IT_CC2);
00002e  2104              MOVS     r1,#4
000030  0708              LSLS     r0,r1,#28
000032  f7fffffe          BL       TIM_ClearITPendingBit
;;;645            TIM_ITConfig(TIM_HARD, TIM_IT_CC2, DISABLE);	/* 禁能CC2中断 */
000036  2200              MOVS     r2,#0
000038  2104              MOVS     r1,#4
00003a  0708              LSLS     r0,r1,#28
00003c  f7fffffe          BL       TIM_ITConfig
;;;646    
;;;647            /* 先关闭中断，再执行回调函数。因为回调函数可能需要重启定时器 */
;;;648            s_TIM_CallBack2();
000040  4813              LDR      r0,|L1.144|
000042  6800              LDR      r0,[r0,#0]  ; s_TIM_CallBack2
000044  4780              BLX      r0
                  |L1.70|
;;;649        }
;;;650    
;;;651        if (TIM_GetITStatus(TIM_HARD, TIM_IT_CC3))
000046  2108              MOVS     r1,#8
000048  06c8              LSLS     r0,r1,#27
00004a  f7fffffe          BL       TIM_GetITStatus
00004e  b158              CBZ      r0,|L1.104|
;;;652        {
;;;653            TIM_ClearITPendingBit(TIM_HARD, TIM_IT_CC3);
000050  2108              MOVS     r1,#8
000052  06c8              LSLS     r0,r1,#27
000054  f7fffffe          BL       TIM_ClearITPendingBit
;;;654            TIM_ITConfig(TIM_HARD, TIM_IT_CC3, DISABLE);	/* 禁能CC3中断 */
000058  2200              MOVS     r2,#0
00005a  2108              MOVS     r1,#8
00005c  06c8              LSLS     r0,r1,#27
00005e  f7fffffe          BL       TIM_ITConfig
;;;655    
;;;656            /* 先关闭中断，再执行回调函数。因为回调函数可能需要重启定时器 */
;;;657            s_TIM_CallBack3();
000062  480c              LDR      r0,|L1.148|
000064  6800              LDR      r0,[r0,#0]  ; s_TIM_CallBack3
000066  4780              BLX      r0
                  |L1.104|
;;;658        }
;;;659    
;;;660        if (TIM_GetITStatus(TIM_HARD, TIM_IT_CC4))
000068  2110              MOVS     r1,#0x10
00006a  0688              LSLS     r0,r1,#26
00006c  f7fffffe          BL       TIM_GetITStatus
000070  b158              CBZ      r0,|L1.138|
;;;661        {
;;;662            TIM_ClearITPendingBit(TIM_HARD, TIM_IT_CC4);
000072  2110              MOVS     r1,#0x10
000074  0688              LSLS     r0,r1,#26
000076  f7fffffe          BL       TIM_ClearITPendingBit
;;;663            TIM_ITConfig(TIM_HARD, TIM_IT_CC4, DISABLE);	/* 禁能CC4中断 */
00007a  2200              MOVS     r2,#0
00007c  2110              MOVS     r1,#0x10
00007e  0688              LSLS     r0,r1,#26
000080  f7fffffe          BL       TIM_ITConfig
;;;664    
;;;665            /* 先关闭中断，再执行回调函数。因为回调函数可能需要重启定时器 */
;;;666            s_TIM_CallBack4();
000084  4804              LDR      r0,|L1.152|
000086  6800              LDR      r0,[r0,#0]  ; s_TIM_CallBack4
000088  4780              BLX      r0
                  |L1.138|
;;;667        }
;;;668    }
00008a  bd10              POP      {r4,pc}
;;;669    
                          ENDP

                  |L1.140|
                          DCD      s_TIM_CallBack1
                  |L1.144|
                          DCD      s_TIM_CallBack2
                  |L1.148|
                          DCD      s_TIM_CallBack3
                  |L1.152|
                          DCD      s_TIM_CallBack4

                          AREA ||i.bsp_InitHardTimer||, CODE, READONLY, ALIGN=2

                  bsp_InitHardTimer PROC
;;;474    #if defined (USE_TIM2) || defined (USE_TIM3)  || defined (USE_TIM4)	|| defined (USE_TIM5)
;;;475    void bsp_InitHardTimer(void)
000000  b57f              PUSH     {r0-r6,lr}
;;;476    {
;;;477    	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;478    	uint32_t usPeriod;
;;;479    	uint16_t usPrescaler;
;;;480    	uint32_t uiTIMxCLK;
;;;481    
;;;482      	/* 使能TIM时钟 */
;;;483    	RCC_APB1PeriphClockCmd(TIM_HARD_RCC, ENABLE);
000002  2101              MOVS     r1,#1
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;484    
;;;485        /*-----------------------------------------------------------------------
;;;486    		system_stm32f4xx.c 文件中 void SetSysClock(void) 函数对时钟的配置如下：
;;;487    
;;;488    		HCLK = SYSCLK / 1     (AHB1Periph)
;;;489    		PCLK2 = HCLK / 2      (APB2Periph)
;;;490    		PCLK1 = HCLK / 4      (APB1Periph)
;;;491    
;;;492    		因为APB1 prescaler != 1, 所以 APB1上的TIMxCLK = PCLK1 x 2 = SystemCoreClock / 2;
;;;493    		因为APB2 prescaler != 1, 所以 APB2上的TIMxCLK = PCLK2 x 2 = SystemCoreClock;
;;;494    
;;;495    		APB1 定时器有 TIM2, TIM3 ,TIM4, TIM5, TIM6, TIM7, TIM12, TIM13,TIM14
;;;496    		APB2 定时器有 TIM1, TIM8 ,TIM9, TIM10, TIM11
;;;497    
;;;498    	----------------------------------------------------------------------- */
;;;499    	uiTIMxCLK = SystemCoreClock / 2;
00000a  4816              LDR      r0,|L2.100|
00000c  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000e  0846              LSRS     r6,r0,#1
;;;500    
;;;501    	//usPrescaler = uiTIMxCLK / 1000000 ;	/* 分频到周期 1us */
;;;502    	usPrescaler = uiTIMxCLK / 1000 ;	/* 分频到周期 1ms */
000010  f44f707a          MOV      r0,#0x3e8
000014  fbb6f0f0          UDIV     r0,r6,r0
000018  b285              UXTH     r5,r0
;;;503    #if defined (USE_TIM2) || defined (USE_TIM5) 
;;;504    	//usPeriod = 0xFFFFFFFF;	/* 407支持32位定时器 */
;;;505    	usPeriod = 0xFFFF;	/* 103支持16位 */
00001a  f64f74ff          MOV      r4,#0xffff
;;;506    #else
;;;507    	usPeriod = 0xFFFF;
;;;508    #endif
;;;509    	/* Time base configuration */
;;;510    	TIM_TimeBaseStructure.TIM_Period = usPeriod;
00001e  f8ad4008          STRH     r4,[sp,#8]
;;;511    	TIM_TimeBaseStructure.TIM_Prescaler = usPrescaler;
000022  f8ad5004          STRH     r5,[sp,#4]
;;;512    	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
000026  2000              MOVS     r0,#0
000028  f8ad000a          STRH     r0,[sp,#0xa]
;;;513    	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
00002c  f8ad0006          STRH     r0,[sp,#6]
;;;514    
;;;515    	TIM_TimeBaseInit(TIM_HARD, &TIM_TimeBaseStructure);
000030  a901              ADD      r1,sp,#4
000032  f04f4080          MOV      r0,#0x40000000
000036  f7fffffe          BL       TIM_TimeBaseInit
;;;516    
;;;517    	//TIM_ARRPreloadConfig(TIMx, ENABLE);
;;;518    
;;;519    	/* TIMx enable counter */
;;;520    	TIM_Cmd(TIM_HARD, ENABLE);
00003a  2101              MOVS     r1,#1
00003c  0788              LSLS     r0,r1,#30
00003e  f7fffffe          BL       TIM_Cmd
;;;521    
;;;522    	/* 配置TIM定时中断 (Update) */
;;;523    	{
;;;524    		NVIC_InitTypeDef NVIC_InitStructure;	/* 中断结构体在 misc.h 中定义 */
;;;525    
;;;526    		NVIC_InitStructure.NVIC_IRQChannel = TIM_HARD_IRQn;
000042  201c              MOVS     r0,#0x1c
000044  f88d0000          STRB     r0,[sp,#0]
;;;527    
;;;528    		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 4;	/* 比串口优先级低 */
000048  2004              MOVS     r0,#4
00004a  f88d0001          STRB     r0,[sp,#1]
;;;529    		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
00004e  2000              MOVS     r0,#0
000050  f88d0002          STRB     r0,[sp,#2]
;;;530    		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000054  2001              MOVS     r0,#1
000056  f88d0003          STRB     r0,[sp,#3]
;;;531    		NVIC_Init(&NVIC_InitStructure);
00005a  4668              MOV      r0,sp
00005c  f7fffffe          BL       NVIC_Init
;;;532    	}
;;;533    }
000060  bd7f              POP      {r0-r6,pc}
;;;534    
                          ENDP

000062  0000              DCW      0x0000
                  |L2.100|
                          DCD      SystemCoreClock

                          AREA ||i.bsp_StartHardTimer||, CODE, READONLY, ALIGN=2

                  bsp_StartHardTimer PROC
;;;547    */
;;;548    void bsp_StartHardTimer(uint8_t _CC, uint32_t _uiTimeOut, void * _pCallBack)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;549    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;550        uint32_t cnt_now;
;;;551        uint32_t cnt_tar;
;;;552    
;;;553        /*
;;;554            执行下面这个语句，时长 = 18us (通过逻辑分析仪测量IO翻转)
;;;555            bsp_StartTimer2(3, 500, (void *)test1);
;;;556        */
;;;557        if (_uiTimeOut < 5)
00000a  2f05              CMP      r7,#5
00000c  d300              BCC      |L3.16|
;;;558        {
;;;559            ;
;;;560        }
;;;561        else
;;;562        {
;;;563            _uiTimeOut -= 5;
00000e  1f7f              SUBS     r7,r7,#5
                  |L3.16|
;;;564        }
;;;565    
;;;566        cnt_now = TIM_GetCounter(TIM_HARD);    	/* 读取当前的计数器值 */
000010  f04f4080          MOV      r0,#0x40000000
000014  f7fffffe          BL       TIM_GetCounter
000018  4680              MOV      r8,r0
;;;567        cnt_tar = cnt_now + _uiTimeOut;			/* 计算捕获的计数器值 */
00001a  eb080607          ADD      r6,r8,r7
;;;568        if (_CC == 1)
00001e  2c01              CMP      r4,#1
000020  d10f              BNE      |L3.66|
;;;569        {
;;;570            s_TIM_CallBack1 = (void (*)(void))_pCallBack;
000022  4825              LDR      r0,|L3.184|
000024  6005              STR      r5,[r0,#0]  ; s_TIM_CallBack1
;;;571    
;;;572            TIM_SetCompare1(TIM_HARD, cnt_tar);      	/* 设置捕获比较计数器CC1 */
000026  b2b1              UXTH     r1,r6
000028  07a0              LSLS     r0,r4,#30
00002a  f7fffffe          BL       TIM_SetCompare1
;;;573            TIM_ClearITPendingBit(TIM_HARD, TIM_IT_CC1);
00002e  2102              MOVS     r1,#2
000030  0748              LSLS     r0,r1,#29
000032  f7fffffe          BL       TIM_ClearITPendingBit
;;;574    		TIM_ITConfig(TIM_HARD, TIM_IT_CC1, ENABLE);	/* 使能CC1中断 */
000036  2201              MOVS     r2,#1
000038  2102              MOVS     r1,#2
00003a  0748              LSLS     r0,r1,#29
00003c  f7fffffe          BL       TIM_ITConfig
000040  e038              B        |L3.180|
                  |L3.66|
;;;575    
;;;576        }
;;;577        else if (_CC == 2)
000042  2c02              CMP      r4,#2
000044  d10f              BNE      |L3.102|
;;;578        {
;;;579    		s_TIM_CallBack2 = (void (*)(void))_pCallBack;
000046  481d              LDR      r0,|L3.188|
000048  6005              STR      r5,[r0,#0]  ; s_TIM_CallBack2
;;;580    
;;;581            TIM_SetCompare2(TIM_HARD, cnt_tar);      	/* 设置捕获比较计数器CC2 */
00004a  b2b1              UXTH     r1,r6
00004c  0760              LSLS     r0,r4,#29
00004e  f7fffffe          BL       TIM_SetCompare2
;;;582    		TIM_ClearITPendingBit(TIM_HARD, TIM_IT_CC2);
000052  2104              MOVS     r1,#4
000054  0708              LSLS     r0,r1,#28
000056  f7fffffe          BL       TIM_ClearITPendingBit
;;;583    		TIM_ITConfig(TIM_HARD, TIM_IT_CC2, ENABLE);	/* 使能CC2中断 */
00005a  2201              MOVS     r2,#1
00005c  2104              MOVS     r1,#4
00005e  0708              LSLS     r0,r1,#28
000060  f7fffffe          BL       TIM_ITConfig
000064  e026              B        |L3.180|
                  |L3.102|
;;;584        }
;;;585        else if (_CC == 3)
000066  2c03              CMP      r4,#3
000068  d110              BNE      |L3.140|
;;;586        {
;;;587            s_TIM_CallBack3 = (void (*)(void))_pCallBack;
00006a  4815              LDR      r0,|L3.192|
00006c  6005              STR      r5,[r0,#0]  ; s_TIM_CallBack3
;;;588    
;;;589            TIM_SetCompare3(TIM_HARD, cnt_tar);      	/* 设置捕获比较计数器CC3 */
00006e  b2b1              UXTH     r1,r6
000070  f04f4080          MOV      r0,#0x40000000
000074  f7fffffe          BL       TIM_SetCompare3
;;;590            TIM_ClearITPendingBit(TIM_HARD, TIM_IT_CC3);
000078  2108              MOVS     r1,#8
00007a  06c8              LSLS     r0,r1,#27
00007c  f7fffffe          BL       TIM_ClearITPendingBit
;;;591    		TIM_ITConfig(TIM_HARD, TIM_IT_CC3, ENABLE);	/* 使能CC3中断 */
000080  2201              MOVS     r2,#1
000082  2108              MOVS     r1,#8
000084  06c8              LSLS     r0,r1,#27
000086  f7fffffe          BL       TIM_ITConfig
00008a  e013              B        |L3.180|
                  |L3.140|
;;;592        }
;;;593        else if (_CC == 4)
00008c  2c04              CMP      r4,#4
00008e  d10f              BNE      |L3.176|
;;;594        {
;;;595            s_TIM_CallBack4 = (void (*)(void))_pCallBack;
000090  480c              LDR      r0,|L3.196|
000092  6005              STR      r5,[r0,#0]  ; s_TIM_CallBack4
;;;596    
;;;597            TIM_SetCompare4(TIM_HARD, cnt_tar);      	/* 设置捕获比较计数器CC4 */
000094  b2b1              UXTH     r1,r6
000096  0720              LSLS     r0,r4,#28
000098  f7fffffe          BL       TIM_SetCompare4
;;;598    		TIM_ClearITPendingBit(TIM_HARD, TIM_IT_CC4);
00009c  2110              MOVS     r1,#0x10
00009e  0688              LSLS     r0,r1,#26
0000a0  f7fffffe          BL       TIM_ClearITPendingBit
;;;599    		TIM_ITConfig(TIM_HARD, TIM_IT_CC4, ENABLE);	/* 使能CC4中断 */
0000a4  2201              MOVS     r2,#1
0000a6  2110              MOVS     r1,#0x10
0000a8  0688              LSLS     r0,r1,#26
0000aa  f7fffffe          BL       TIM_ITConfig
0000ae  e001              B        |L3.180|
                  |L3.176|
;;;600        }
;;;601    	else
;;;602        {
;;;603            return;
;;;604        }
;;;605    }
0000b0  e8bd81f0          POP      {r4-r8,pc}
                  |L3.180|
0000b4  bf00              NOP      
0000b6  e7fb              B        |L3.176|
;;;606    #endif
                          ENDP

                  |L3.184|
                          DCD      s_TIM_CallBack1
                  |L3.188|
                          DCD      s_TIM_CallBack2
                  |L3.192|
                          DCD      s_TIM_CallBack3
                  |L3.196|
                          DCD      s_TIM_CallBack4

                          AREA ||.data||, DATA, ALIGN=2

                  s_TIM_CallBack1
                          DCD      0x00000000
                  s_TIM_CallBack2
                          DCD      0x00000000
                  s_TIM_CallBack3
                          DCD      0x00000000
                  s_TIM_CallBack4
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\Timer\\bsp_timer.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_bsp_timer_c_3cb1b625____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_bsp_timer_c_3cb1b625____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_bsp_timer_c_3cb1b625____REVSH|
#line 128
|__asm___11_bsp_timer_c_3cb1b625____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
