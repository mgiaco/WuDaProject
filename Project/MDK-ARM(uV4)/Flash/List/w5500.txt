; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\w5500.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\w5500.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\RTX\inc -I..\..\RTX\portable -I..\..\User\CpuFlash -I..\..\User\CRC8_16 -I..\..\User\DS1302 -I..\..\User\DWT -I..\..\User\IIC -I..\..\User\IWDG -I..\..\User\Key -I..\..\User\Led -I..\..\User\Net -I..\..\User\Protocal -I..\..\User\Reader -I..\..\User\SPI -I..\..\User\Timer -I..\..\User\Uart -I..\..\User\Param -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\w5500.crf ..\..\User\Net\w5500.c]
                          THUMB

                          AREA ||i.IINCHIP_CSoff||, CODE, READONLY, ALIGN=1

                  IINCHIP_CSoff PROC
;;;28     }
;;;29     void IINCHIP_CSoff(void)
000000  b510              PUSH     {r4,lr}
;;;30     {
;;;31       WIZ_CS(LOW);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       WIZ_CS
;;;32     }
000008  bd10              POP      {r4,pc}
;;;33     void IINCHIP_CSon(void)
                          ENDP


                          AREA ||i.IINCHIP_CSon||, CODE, READONLY, ALIGN=1

                  IINCHIP_CSon PROC
;;;32     }
;;;33     void IINCHIP_CSon(void)
000000  b510              PUSH     {r4,lr}
;;;34     {
;;;35        WIZ_CS(HIGH);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       WIZ_CS
;;;36     }
000008  bd10              POP      {r4,pc}
;;;37     u8  IINCHIP_SpiSendData(uint8 dat)
                          ENDP


                          AREA ||i.IINCHIP_READ||, CODE, READONLY, ALIGN=1

                  IINCHIP_READ PROC
;;;53     
;;;54     uint8 IINCHIP_READ(uint32 addrbsb)
000000  b570              PUSH     {r4-r6,lr}
;;;55     {
000002  4604              MOV      r4,r0
;;;56        uint8 data = 0;
000004  2500              MOVS     r5,#0
;;;57        //IINCHIP_ISR_DISABLE();                        // Interrupt Service Routine Disable
;;;58        IINCHIP_CSoff();                              // CS=0, SPI start
000006  f7fffffe          BL       IINCHIP_CSoff
;;;59        IINCHIP_SpiSendData( (addrbsb & 0x00FF0000)>>16);// Address byte 1
00000a  f3c44007          UBFX     r0,r4,#16,#8
00000e  f7fffffe          BL       IINCHIP_SpiSendData
;;;60        IINCHIP_SpiSendData( (addrbsb & 0x0000FF00)>> 8);// Address byte 2
000012  f3c42007          UBFX     r0,r4,#8,#8
000016  f7fffffe          BL       IINCHIP_SpiSendData
;;;61        IINCHIP_SpiSendData( (addrbsb & 0x000000F8))    ;// Data read command and Read data length 1
00001a  f00400f8          AND      r0,r4,#0xf8
00001e  f7fffffe          BL       IINCHIP_SpiSendData
;;;62        data = IINCHIP_SpiSendData(0x00);             // Data read (read 1byte data)
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       IINCHIP_SpiSendData
000028  4605              MOV      r5,r0
;;;63        IINCHIP_CSon();                               // CS=1,  SPI end
00002a  f7fffffe          BL       IINCHIP_CSon
;;;64        //IINCHIP_ISR_ENABLE();                         // Interrupt Service Routine Enable
;;;65        return data;    
00002e  4628              MOV      r0,r5
;;;66     }
000030  bd70              POP      {r4-r6,pc}
;;;67     
                          ENDP


                          AREA ||i.IINCHIP_SpiSendData||, CODE, READONLY, ALIGN=1

                  IINCHIP_SpiSendData PROC
;;;36     }
;;;37     u8  IINCHIP_SpiSendData(uint8 dat)
000000  b510              PUSH     {r4,lr}
;;;38     {
000002  4604              MOV      r4,r0
;;;39        return(SPI2_SendByte(dat));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       SPI2_SendByte
;;;40     }
00000a  bd10              POP      {r4,pc}
;;;41     
                          ENDP


                          AREA ||i.IINCHIP_WRITE||, CODE, READONLY, ALIGN=1

                  IINCHIP_WRITE PROC
;;;41     
;;;42     void IINCHIP_WRITE( uint32 addrbsb,  uint8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;43     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;44        //IINCHIP_ISR_DISABLE();                        // Interrupt Service Routine Disable
;;;45        IINCHIP_CSoff();                              // CS=0, SPI start
000006  f7fffffe          BL       IINCHIP_CSoff
;;;46        IINCHIP_SpiSendData( (addrbsb & 0x00FF0000)>>16);// Address byte 1
00000a  f3c44007          UBFX     r0,r4,#16,#8
00000e  f7fffffe          BL       IINCHIP_SpiSendData
;;;47        IINCHIP_SpiSendData( (addrbsb & 0x0000FF00)>> 8);// Address byte 2
000012  f3c42007          UBFX     r0,r4,#8,#8
000016  f7fffffe          BL       IINCHIP_SpiSendData
;;;48        IINCHIP_SpiSendData( (addrbsb & 0x000000F8) + 4);    // Data write command and Write data length 1
00001a  f00401f8          AND      r1,r4,#0xf8
00001e  1d09              ADDS     r1,r1,#4
000020  b2c8              UXTB     r0,r1
000022  f7fffffe          BL       IINCHIP_SpiSendData
;;;49        IINCHIP_SpiSendData(data);                    // Data write (write 1byte data)
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       IINCHIP_SpiSendData
;;;50        IINCHIP_CSon();                               // CS=1,  SPI end
00002c  f7fffffe          BL       IINCHIP_CSon
;;;51        //IINCHIP_ISR_ENABLE();                         // Interrupt Service Routine Enable
;;;52     }
000030  bd70              POP      {r4-r6,pc}
;;;53     
                          ENDP


                          AREA ||i.clearIR||, CODE, READONLY, ALIGN=1

                  clearIR PROC
;;;333    */
;;;334    void clearIR(uint8 mask)
000000  b570              PUSH     {r4-r6,lr}
;;;335    {
000002  4604              MOV      r4,r0
;;;336      IINCHIP_WRITE(IR, ~mask | getIR() ); // must be setted 0x10.
000004  f7fffffe          BL       getIR
000008  ea600004          ORN      r0,r0,r4
00000c  b2c5              UXTB     r5,r0
00000e  4629              MOV      r1,r5
000010  f44f50a8          MOV      r0,#0x1500
000014  f7fffffe          BL       IINCHIP_WRITE
;;;337    }
000018  bd70              POP      {r4-r6,pc}
;;;338    
                          ENDP


                          AREA ||i.getGAR||, CODE, READONLY, ALIGN=1

                  getGAR PROC
;;;274    */
;;;275    void getGAR(uint8 * addr)
000000  b510              PUSH     {r4,lr}
;;;276    {
000002  4604              MOV      r4,r0
;;;277        wiz_read_buf(GAR0, addr, 4);
000004  2204              MOVS     r2,#4
000006  4621              MOV      r1,r4
000008  0190              LSLS     r0,r2,#6
00000a  f7fffffe          BL       wiz_read_buf
;;;278    }
00000e  bd10              POP      {r4,pc}
;;;279    void getSUBR(uint8 * addr)
                          ENDP


                          AREA ||i.getGWIP||, CODE, READONLY, ALIGN=1

                  getGWIP PROC
;;;231    }
;;;232    void getGWIP(uint8 * addr)
000000  b510              PUSH     {r4,lr}
;;;233    {
000002  4604              MOV      r4,r0
;;;234        wiz_read_buf(GAR0, addr, 4);
000004  2204              MOVS     r2,#4
000006  4621              MOV      r1,r4
000008  0190              LSLS     r0,r2,#6
00000a  f7fffffe          BL       wiz_read_buf
;;;235    }
00000e  bd10              POP      {r4,pc}
;;;236    
                          ENDP


                          AREA ||i.getIINCHIP_RxMAX||, CODE, READONLY, ALIGN=2

                  getIINCHIP_RxMAX PROC
;;;20     
;;;21     uint16 getIINCHIP_RxMAX(uint8 s)
000000  4601              MOV      r1,r0
;;;22     {
;;;23        return RSIZE[s];
000002  4802              LDR      r0,|L9.12|
000004  f8300011          LDRH     r0,[r0,r1,LSL #1]
;;;24     }
000008  4770              BX       lr
;;;25     uint16 getIINCHIP_TxMAX(uint8 s)
                          ENDP

00000a  0000              DCW      0x0000
                  |L9.12|
                          DCD      RSIZE

                          AREA ||i.getIINCHIP_TxMAX||, CODE, READONLY, ALIGN=2

                  getIINCHIP_TxMAX PROC
;;;24     }
;;;25     uint16 getIINCHIP_TxMAX(uint8 s)
000000  4601              MOV      r1,r0
;;;26     {
;;;27        return SSIZE[s];
000002  4802              LDR      r0,|L10.12|
000004  f8300011          LDRH     r0,[r0,r1,LSL #1]
;;;28     }
000008  4770              BX       lr
;;;29     void IINCHIP_CSoff(void)
                          ENDP

00000a  0000              DCW      0x0000
                  |L10.12|
                          DCD      SSIZE

                          AREA ||i.getIR||, CODE, READONLY, ALIGN=1

                  getIR PROC
;;;299     */
;;;300    uint8 getIR( void )
000000  b510              PUSH     {r4,lr}
;;;301    {
;;;302       return IINCHIP_READ(IR);
000002  f44f50a8          MOV      r0,#0x1500
000006  f7fffffe          BL       IINCHIP_READ
;;;303    }
00000a  bd10              POP      {r4,pc}
;;;304    
                          ENDP


                          AREA ||i.getISR||, CODE, READONLY, ALIGN=2

                  getISR PROC
;;;11     
;;;12     uint8 getISR(uint8 s)
000000  4601              MOV      r1,r0
;;;13     {
;;;14       return I_STATUS[s];
000002  4801              LDR      r0,|L12.8|
000004  5c40              LDRB     r0,[r0,r1]
;;;15     }
000006  4770              BX       lr
;;;16     void putISR(uint8 s, uint8 val)
                          ENDP

                  |L12.8|
                          DCD      I_STATUS

                          AREA ||i.getSHAR||, CODE, READONLY, ALIGN=1

                  getSHAR PROC
;;;282    }
;;;283    void getSHAR(uint8 * addr)
000000  b510              PUSH     {r4,lr}
;;;284    {
000002  4604              MOV      r4,r0
;;;285        wiz_read_buf(SHAR0, addr, 6);
000004  2206              MOVS     r2,#6
000006  4621              MOV      r1,r4
000008  f44f6010          MOV      r0,#0x900
00000c  f7fffffe          BL       wiz_read_buf
;;;286    }
000010  bd10              POP      {r4,pc}
;;;287    void getSIPR(uint8 * addr)
                          ENDP


                          AREA ||i.getSIPR||, CODE, READONLY, ALIGN=1

                  getSIPR PROC
;;;286    }
;;;287    void getSIPR(uint8 * addr)
000000  b510              PUSH     {r4,lr}
;;;288    {
000002  4604              MOV      r4,r0
;;;289        wiz_read_buf(SIPR0, addr, 4);
000004  2204              MOVS     r2,#4
000006  4621              MOV      r1,r4
000008  f44f6070          MOV      r0,#0xf00
00000c  f7fffffe          BL       wiz_read_buf
;;;290    }
000010  bd10              POP      {r4,pc}
;;;291    
                          ENDP


                          AREA ||i.getSUBR||, CODE, READONLY, ALIGN=1

                  getSUBR PROC
;;;278    }
;;;279    void getSUBR(uint8 * addr)
000000  b510              PUSH     {r4,lr}
;;;280    {
000002  4604              MOV      r4,r0
;;;281        wiz_read_buf(SUBR0, addr, 4);
000004  2204              MOVS     r2,#4
000006  4621              MOV      r1,r4
000008  f44f60a0          MOV      r0,#0x500
00000c  f7fffffe          BL       wiz_read_buf
;;;282    }
000010  bd10              POP      {r4,pc}
;;;283    void getSHAR(uint8 * addr)
                          ENDP


                          AREA ||i.getSn_IR||, CODE, READONLY, ALIGN=1

                  getSn_IR PROC
;;;359    */
;;;360    uint8 getSn_IR(SOCKET s)
000000  b510              PUSH     {r4,lr}
;;;361    {
000002  4604              MOV      r4,r0
;;;362       return IINCHIP_READ(Sn_IR(s));
000004  f44f7102          MOV      r1,#0x208
000008  eb011044          ADD      r0,r1,r4,LSL #5
00000c  f7fffffe          BL       IINCHIP_READ
;;;363    }
000010  bd10              POP      {r4,pc}
;;;364    
                          ENDP


                          AREA ||i.getSn_RX_RSR||, CODE, READONLY, ALIGN=1

                  getSn_RX_RSR PROC
;;;402    */
;;;403    uint16 getSn_RX_RSR(SOCKET s)		// 获取Sn_RX_RSR空闲接收缓存寄存器的值并返回,Sn_RX_RSR中保存的是接收缓存中已接收和保存的数据大小
000000  b570              PUSH     {r4-r6,lr}
;;;404    {
000002  4604              MOV      r4,r0
;;;405      uint16 val=0,val1=0;
000004  2500              MOVS     r5,#0
000006  2600              MOVS     r6,#0
;;;406      do
000008  bf00              NOP      
                  |L17.10|
;;;407      {
;;;408        val1 = IINCHIP_READ(Sn_RX_RSR0(s));		
00000a  f2426108          MOV      r1,#0x2608
00000e  eb011044          ADD      r0,r1,r4,LSL #5
000012  f7fffffe          BL       IINCHIP_READ
000016  4606              MOV      r6,r0
;;;409        val1 = (val1 << 8) + IINCHIP_READ(Sn_RX_RSR1(s));		// MCU读出Sn_RX_RSR的值赋给val1
000018  f2427108          MOV      r1,#0x2708
00001c  eb011044          ADD      r0,r1,r4,LSL #5
000020  f7fffffe          BL       IINCHIP_READ
000024  eb002006          ADD      r0,r0,r6,LSL #8
000028  b286              UXTH     r6,r0
;;;410        if(val1 != 0)																				// 如果Sn_RX_RSR的值不为0，说明接收缓存中收到了数据
00002a  b17e              CBZ      r6,|L17.76|
;;;411        {
;;;412            val = IINCHIP_READ(Sn_RX_RSR0(s));				
00002c  f2426108          MOV      r1,#0x2608
000030  eb011044          ADD      r0,r1,r4,LSL #5
000034  f7fffffe          BL       IINCHIP_READ
000038  4605              MOV      r5,r0
;;;413            val = (val << 8) + IINCHIP_READ(Sn_RX_RSR1(s));	// MCU读出Sn_RX_RSR的值赋给val
00003a  f2427108          MOV      r1,#0x2708
00003e  eb011044          ADD      r0,r1,r4,LSL #5
000042  f7fffffe          BL       IINCHIP_READ
000046  eb002005          ADD      r0,r0,r5,LSL #8
00004a  b285              UXTH     r5,r0
                  |L17.76|
;;;414        }
;;;415      } 
;;;416    	while (val != val1);																	// 此时应该val=val1,表达式为假，跳出do while循环
00004c  42b5              CMP      r5,r6
00004e  d1dc              BNE      |L17.10|
;;;417      return val;																						// 返回val
000050  4628              MOV      r0,r5
;;;418    }
000052  bd70              POP      {r4-r6,pc}
;;;419    
                          ENDP


                          AREA ||i.getSn_SR||, CODE, READONLY, ALIGN=1

                  getSn_SR PROC
;;;368    */
;;;369    uint8 getSn_SR(SOCKET s)
000000  b510              PUSH     {r4,lr}
;;;370    {
000002  4604              MOV      r4,r0
;;;371       return IINCHIP_READ(Sn_SR(s)); // MCU读Sn_SR对应地址里面的数值并返回
000004  f44f7142          MOV      r1,#0x308
000008  eb011044          ADD      r0,r1,r4,LSL #5
00000c  f7fffffe          BL       IINCHIP_READ
;;;372    }
000010  bd10              POP      {r4,pc}
;;;373    
                          ENDP


                          AREA ||i.getSn_TX_FSR||, CODE, READONLY, ALIGN=1

                  getSn_TX_FSR PROC
;;;380    */
;;;381    uint16 getSn_TX_FSR(SOCKET s)
000000  b570              PUSH     {r4-r6,lr}
;;;382    {
000002  4604              MOV      r4,r0
;;;383      uint16 val=0,val1=0;
000004  2500              MOVS     r5,#0
000006  2600              MOVS     r6,#0
;;;384      do
000008  bf00              NOP      
                  |L19.10|
;;;385      {
;;;386        val1 = IINCHIP_READ(Sn_TX_FSR0(s));
00000a  f2420108          MOV      r1,#0x2008
00000e  eb011044          ADD      r0,r1,r4,LSL #5
000012  f7fffffe          BL       IINCHIP_READ
000016  4606              MOV      r6,r0
;;;387        val1 = (val1 << 8) + IINCHIP_READ(Sn_TX_FSR1(s));
000018  f2421108          MOV      r1,#0x2108
00001c  eb011044          ADD      r0,r1,r4,LSL #5
000020  f7fffffe          BL       IINCHIP_READ
000024  eb002006          ADD      r0,r0,r6,LSL #8
000028  b286              UXTH     r6,r0
;;;388          if (val1 != 0)
00002a  b17e              CBZ      r6,|L19.76|
;;;389        {
;;;390            val = IINCHIP_READ(Sn_TX_FSR0(s));
00002c  f2420108          MOV      r1,#0x2008
000030  eb011044          ADD      r0,r1,r4,LSL #5
000034  f7fffffe          BL       IINCHIP_READ
000038  4605              MOV      r5,r0
;;;391            val = (val << 8) + IINCHIP_READ(Sn_TX_FSR1(s));
00003a  f2421108          MOV      r1,#0x2108
00003e  eb011044          ADD      r0,r1,r4,LSL #5
000042  f7fffffe          BL       IINCHIP_READ
000046  eb002005          ADD      r0,r0,r5,LSL #8
00004a  b285              UXTH     r5,r0
                  |L19.76|
;;;392        }
;;;393      } while (val != val1);
00004c  42b5              CMP      r5,r6
00004e  d1dc              BNE      |L19.10|
;;;394       return val;
000050  4628              MOV      r0,r5
;;;395    }
000052  bd70              POP      {r4-r6,pc}
;;;396    
                          ENDP


                          AREA ||i.iinchip_init||, CODE, READONLY, ALIGN=1

                  iinchip_init PROC
;;;115    */
;;;116    void iinchip_init(void)
000000  b510              PUSH     {r4,lr}
;;;117    {
;;;118      setMR( MR_RST );
000002  2080              MOVS     r0,#0x80
000004  f7fffffe          BL       setMR
;;;119    #ifdef __DEF_IINCHIP_DBG__
;;;120      printf("MR value is %02x \r\n",IINCHIP_READ_COMMON(MR));
;;;121    #endif
;;;122    }
000008  bd10              POP      {r4,pc}
;;;123    
                          ENDP


                          AREA ||i.putISR||, CODE, READONLY, ALIGN=2

                  putISR PROC
;;;15     }
;;;16     void putISR(uint8 s, uint8 val)
000000  4a01              LDR      r2,|L21.8|
;;;17     {
;;;18        I_STATUS[s] = val;
000002  5411              STRB     r1,[r2,r0]
;;;19     }
000004  4770              BX       lr
;;;20     
                          ENDP

000006  0000              DCW      0x0000
                  |L21.8|
                          DCD      I_STATUS

                          AREA ||i.recv_data_processing||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  recv_data_processing PROC
;;;456    */
;;;457    void recv_data_processing(SOCKET s, uint8 *data, uint16 len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;458    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;459      uint16 ptr = 0;
00000a  2500              MOVS     r5,#0
;;;460      uint32 addrbsb = 0;
00000c  46a8              MOV      r8,r5
;;;461      
;;;462      if(len == 0)
00000e  b92e              CBNZ     r6,|L22.28|
;;;463      {
;;;464        printf("CH: %d Unexpected2 length 0\r\n", s);
000010  4621              MOV      r1,r4
000012  a018              ADR      r0,|L22.116|
000014  f7fffffe          BL       __2printf
                  |L22.24|
;;;465        return;
;;;466      }
;;;467    // Sn_RX_RD是发送读指针寄存器
;;;468      ptr = IINCHIP_READ( Sn_RX_RD0(s) );			
;;;469      ptr = ((ptr & 0x00ff) << 8) + IINCHIP_READ( Sn_RX_RD1(s) );			// MCU读取Sn_RX_RD寄存器的值
;;;470    
;;;471      addrbsb = (uint32)(ptr<<8) + (s<<5) + 0x18;					// 将发送缓存中将要传输数据的首地址转成32位
;;;472      wiz_read_buf(addrbsb, data, len);										// W5500从该首地址开始读取数据，数据长度为len
;;;473      ptr += len;																					// 首地址的值+len变为数据新的首地址
;;;474    
;;;475      IINCHIP_WRITE( Sn_RX_RD0(s), (uint8)((ptr & 0xff00) >> 8));		
;;;476      IINCHIP_WRITE( Sn_RX_RD1(s), (uint8)(ptr & 0x00ff));		// 将新的首地址保存在Sn_RX_RD中
;;;477    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L22.28|
00001c  f6420108          MOV      r1,#0x2808            ;468
000020  eb011044          ADD      r0,r1,r4,LSL #5       ;468
000024  f7fffffe          BL       IINCHIP_READ
000028  4605              MOV      r5,r0                 ;468
00002a  f6421108          MOV      r1,#0x2908            ;469
00002e  eb011044          ADD      r0,r1,r4,LSL #5       ;469
000032  f7fffffe          BL       IINCHIP_READ
000036  eb002005          ADD      r0,r0,r5,LSL #8       ;469
00003a  b285              UXTH     r5,r0                 ;469
00003c  0228              LSLS     r0,r5,#8              ;471
00003e  eb001044          ADD      r0,r0,r4,LSL #5       ;471
000042  f1000818          ADD      r8,r0,#0x18           ;471
000046  4632              MOV      r2,r6                 ;472
000048  4639              MOV      r1,r7                 ;472
00004a  4640              MOV      r0,r8                 ;472
00004c  f7fffffe          BL       wiz_read_buf
000050  19a8              ADDS     r0,r5,r6              ;473
000052  b285              UXTH     r5,r0                 ;473
000054  0a29              LSRS     r1,r5,#8              ;475
000056  f6420208          MOV      r2,#0x2808            ;475
00005a  eb021044          ADD      r0,r2,r4,LSL #5       ;475
00005e  f7fffffe          BL       IINCHIP_WRITE
000062  b2e9              UXTB     r1,r5                 ;476
000064  f6421208          MOV      r2,#0x2908            ;476
000068  eb021044          ADD      r0,r2,r4,LSL #5       ;476
00006c  f7fffffe          BL       IINCHIP_WRITE
000070  bf00              NOP      
000072  e7d1              B        |L22.24|
;;;478    
                          ENDP

                  |L22.116|
000074  43483a20          DCB      "CH: %d Unexpected2 length 0\r\n",0
000078  25642055
00007c  6e657870
000080  65637465
000084  6432206c
000088  656e6774
00008c  6820300d
000090  0a00    
000092  00                DCB      0
000093  00                DCB      0

                          AREA ||i.send_data_processing||, CODE, READONLY, ALIGN=1

                  send_data_processing PROC
;;;426    */
;;;427    void send_data_processing(SOCKET s, uint8 *data, uint16 len)		// MCU把数据发送给W5500的过程，W5500将数据写入buf，并更新数据的写指针的地址
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;428    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;429      uint16 ptr =0;
00000a  2500              MOVS     r5,#0
;;;430      uint32 addrbsb =0;
00000c  46a8              MOV      r8,r5
;;;431      if(len == 0)
00000e  b90e              CBNZ     r6,|L23.20|
                  |L23.16|
;;;432      {
;;;433        //printf("CH: %d Unexpected1 length 0\r\n", s);
;;;434        return;
;;;435      }
;;;436    
;;;437    // Sn_RX_WR是发送写指针寄存器，用来保存发送缓存中将要传输数据的首地址 
;;;438      ptr = IINCHIP_READ( Sn_TX_WR0(s) );
;;;439      ptr = ((ptr & 0x00ff) << 8) + IINCHIP_READ(Sn_TX_WR1(s));			// MCU读取Sn_RX_WR寄存器的值
;;;440    
;;;441      addrbsb = (uint32)(ptr<<8) + (s<<5) + 0x10;										// 将发送缓存中将要传输数据的首地址转成32位
;;;442      wiz_write_buf(addrbsb, data, len);														// W5500从该首地址开始写入数据，数据长度为len
;;;443      
;;;444      ptr += len;																										// 首地址的值+len变为数据新的首地址
;;;445      IINCHIP_WRITE( Sn_TX_WR0(s) ,(uint8)((ptr & 0xff00) >> 8));
;;;446      IINCHIP_WRITE( Sn_TX_WR1(s),(uint8)(ptr & 0x00ff));						// 将新的首地址保存在Sn_RX_WR中
;;;447    }
000010  e8bd81f0          POP      {r4-r8,pc}
                  |L23.20|
000014  f2424108          MOV      r1,#0x2408            ;438
000018  eb011044          ADD      r0,r1,r4,LSL #5       ;438
00001c  f7fffffe          BL       IINCHIP_READ
000020  4605              MOV      r5,r0                 ;438
000022  f2425108          MOV      r1,#0x2508            ;439
000026  eb011044          ADD      r0,r1,r4,LSL #5       ;439
00002a  f7fffffe          BL       IINCHIP_READ
00002e  eb002005          ADD      r0,r0,r5,LSL #8       ;439
000032  b285              UXTH     r5,r0                 ;439
000034  0228              LSLS     r0,r5,#8              ;441
000036  eb001044          ADD      r0,r0,r4,LSL #5       ;441
00003a  f1000810          ADD      r8,r0,#0x10           ;441
00003e  4632              MOV      r2,r6                 ;442
000040  4639              MOV      r1,r7                 ;442
000042  4640              MOV      r0,r8                 ;442
000044  f7fffffe          BL       wiz_write_buf
000048  19a8              ADDS     r0,r5,r6              ;444
00004a  b285              UXTH     r5,r0                 ;444
00004c  0a29              LSRS     r1,r5,#8              ;445
00004e  f2424208          MOV      r2,#0x2408            ;445
000052  eb021044          ADD      r0,r2,r4,LSL #5       ;445
000056  f7fffffe          BL       IINCHIP_WRITE
00005a  b2e9              UXTB     r1,r5                 ;446
00005c  f2425208          MOV      r2,#0x2508            ;446
000060  eb021044          ADD      r0,r2,r4,LSL #5       ;446
000064  f7fffffe          BL       IINCHIP_WRITE
000068  bf00              NOP      
00006a  e7d1              B        |L23.16|
;;;448    
                          ENDP


                          AREA ||i.setGAR||, CODE, READONLY, ALIGN=1

                  setGAR PROC
;;;225    */
;;;226    void setGAR(
000000  b510              PUSH     {r4,lr}
;;;227      uint8 * addr  /**< a pointer to a 4 -byte array responsible to set the Gateway IP address. */
;;;228      )
;;;229    {
000002  4604              MOV      r4,r0
;;;230        wiz_write_buf(GAR0, addr, 4);
000004  2204              MOVS     r2,#4
000006  4621              MOV      r1,r4
000008  0190              LSLS     r0,r2,#6
00000a  f7fffffe          BL       wiz_write_buf
;;;231    }
00000e  bd10              POP      {r4,pc}
;;;232    void getGWIP(uint8 * addr)
                          ENDP


                          AREA ||i.setMR||, CODE, READONLY, ALIGN=1

                  setMR PROC
;;;291    
;;;292    void setMR(uint8 val)
000000  b510              PUSH     {r4,lr}
;;;293    {
000002  4604              MOV      r4,r0
;;;294      IINCHIP_WRITE(MR,val);
000004  4621              MOV      r1,r4
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       IINCHIP_WRITE
;;;295    }
00000c  bd10              POP      {r4,pc}
;;;296    
                          ENDP


                          AREA ||i.setRCR||, CODE, READONLY, ALIGN=1

                  setRCR PROC
;;;322    */
;;;323    void setRCR(uint8 retry)
000000  b510              PUSH     {r4,lr}
;;;324    {
000002  4604              MOV      r4,r0
;;;325      IINCHIP_WRITE(WIZ_RCR,retry);
000004  4621              MOV      r1,r4
000006  f44f50d8          MOV      r0,#0x1b00
00000a  f7fffffe          BL       IINCHIP_WRITE
;;;326    }
00000e  bd10              POP      {r4,pc}
;;;327    
                          ENDP


                          AREA ||i.setRTR||, CODE, READONLY, ALIGN=1

                  setRTR PROC
;;;310    */
;;;311    void setRTR(uint16 timeout)
000000  b510              PUSH     {r4,lr}
;;;312    {
000002  4604              MOV      r4,r0
;;;313      IINCHIP_WRITE(RTR0,(uint8)((timeout & 0xff00) >> 8));
000004  0a21              LSRS     r1,r4,#8
000006  f44f50c8          MOV      r0,#0x1900
00000a  f7fffffe          BL       IINCHIP_WRITE
;;;314      IINCHIP_WRITE(RTR1,(uint8)(timeout & 0x00ff));
00000e  b2e1              UXTB     r1,r4
000010  f44f50d0          MOV      r0,#0x1a00
000014  f7fffffe          BL       IINCHIP_WRITE
;;;315    }
000018  bd10              POP      {r4,pc}
;;;316    
                          ENDP


                          AREA ||i.setSHAR||, CODE, READONLY, ALIGN=1

                  setSHAR PROC
;;;246    */
;;;247    void setSHAR(
000000  b510              PUSH     {r4,lr}
;;;248      uint8 * addr  /**< a pointer to a 6 -byte array responsible to set the MAC address. */
;;;249      )
;;;250    {
000002  4604              MOV      r4,r0
;;;251      wiz_write_buf(SHAR0, addr, 6);  
000004  2206              MOVS     r2,#6
000006  4621              MOV      r1,r4
000008  f44f6010          MOV      r0,#0x900
00000c  f7fffffe          BL       wiz_write_buf
;;;252    }
000010  bd10              POP      {r4,pc}
;;;253    
                          ENDP


                          AREA ||i.setSIPR||, CODE, READONLY, ALIGN=1

                  setSIPR PROC
;;;256    */
;;;257    void setSIPR(
000000  b510              PUSH     {r4,lr}
;;;258      uint8 * addr  /**< a pointer to a 4 -byte array responsible to set the Source IP address. */
;;;259      )
;;;260    {
000002  4604              MOV      r4,r0
;;;261        wiz_write_buf(SIPR0, addr, 4);  
000004  2204              MOVS     r2,#4
000006  4621              MOV      r1,r4
000008  f44f6070          MOV      r0,#0xf00
00000c  f7fffffe          BL       wiz_write_buf
;;;262    }
000010  bd10              POP      {r4,pc}
;;;263    
                          ENDP


                          AREA ||i.setSUBR||, CODE, READONLY, ALIGN=1

                  setSUBR PROC
;;;239    */
;;;240    void setSUBR(uint8 * addr)
000000  b510              PUSH     {r4,lr}
;;;241    {   
000002  4604              MOV      r4,r0
;;;242        wiz_write_buf(SUBR0, addr, 4);
000004  2204              MOVS     r2,#4
000006  4621              MOV      r1,r4
000008  f44f60a0          MOV      r0,#0x500
00000c  f7fffffe          BL       wiz_write_buf
;;;243    }
000010  bd10              POP      {r4,pc}
;;;244    /**
                          ENDP


                          AREA ||i.setSn_IR||, CODE, READONLY, ALIGN=1

                  setSn_IR PROC
;;;478    
;;;479    void setSn_IR(uint8 s, uint8 val)
000000  b570              PUSH     {r4-r6,lr}
;;;480    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;481        IINCHIP_WRITE(Sn_IR(s), val);
000006  f44f7102          MOV      r1,#0x208
00000a  eb011044          ADD      r0,r1,r4,LSL #5
00000e  4629              MOV      r1,r5
000010  f7fffffe          BL       IINCHIP_WRITE
;;;482    }
000014  bd70              POP      {r4-r6,pc}
;;;483    
                          ENDP


                          AREA ||i.setSn_MSS||, CODE, READONLY, ALIGN=1

                  setSn_MSS PROC
;;;341    */
;;;342    void setSn_MSS(SOCKET s, uint16 Sn_MSSR)
000000  b570              PUSH     {r4-r6,lr}
;;;343    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;344      IINCHIP_WRITE( Sn_MSSR0(s), (uint8)((Sn_MSSR & 0xff00) >> 8));
000006  0a29              LSRS     r1,r5,#8
000008  f2412208          MOV      r2,#0x1208
00000c  eb021044          ADD      r0,r2,r4,LSL #5
000010  f7fffffe          BL       IINCHIP_WRITE
;;;345      IINCHIP_WRITE( Sn_MSSR1(s), (uint8)(Sn_MSSR & 0x00ff));
000014  b2e9              UXTB     r1,r5
000016  f2413208          MOV      r2,#0x1308
00001a  eb021044          ADD      r0,r2,r4,LSL #5
00001e  f7fffffe          BL       IINCHIP_WRITE
;;;346    }
000022  bd70              POP      {r4-r6,pc}
;;;347    
                          ENDP


                          AREA ||i.setSn_TTL||, CODE, READONLY, ALIGN=1

                  setSn_TTL PROC
;;;347    
;;;348    void setSn_TTL(SOCKET s, uint8 ttl)
000000  b570              PUSH     {r4-r6,lr}
;;;349    {    
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;350       IINCHIP_WRITE( Sn_TTL(s) , ttl);
000006  f2416108          MOV      r1,#0x1608
00000a  eb011044          ADD      r0,r1,r4,LSL #5
00000e  4629              MOV      r1,r5
000010  f7fffffe          BL       IINCHIP_WRITE
;;;351    }
000014  bd70              POP      {r4-r6,pc}
;;;352    
                          ENDP


                          AREA ||i.setkeepalive||, CODE, READONLY, ALIGN=1

                  setkeepalive PROC
;;;266    */
;;;267    void setkeepalive(SOCKET s)
000000  b510              PUSH     {r4,lr}
;;;268    { 
000002  4604              MOV      r4,r0
;;;269      IINCHIP_WRITE(Sn_KPALVTR(s),0x02);
000004  f6427108          MOV      r1,#0x2f08
000008  eb011044          ADD      r0,r1,r4,LSL #5
00000c  2102              MOVS     r1,#2
00000e  f7fffffe          BL       IINCHIP_WRITE
;;;270    }
000012  bd10              POP      {r4,pc}
;;;271    
                          ENDP


                          AREA ||i.sysinit||, CODE, READONLY, ALIGN=2

                  sysinit PROC
;;;143    */
;;;144    void sysinit( uint8 * tx_size, uint8 * rx_size  )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;145    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;146      int16 i;
;;;147      int16 ssum,rsum;
;;;148    #ifdef __DEF_IINCHIP_DBG__
;;;149      printf("sysinit()\r\n");
;;;150    #endif
;;;151      ssum = 0;
000008  2700              MOVS     r7,#0
;;;152      rsum = 0;
00000a  46b8              MOV      r8,r7
;;;153    
;;;154      for (i = 0 ; i < MAX_SOCK_NUM; i++)       // Set the size, masking and base address of Tx & Rx memory by each channel
00000c  2400              MOVS     r4,#0
00000e  e089              B        |L35.292|
                  |L35.16|
;;;155      {
;;;156              IINCHIP_WRITE( (Sn_TXMEM_SIZE(i)), tx_size[i]);		// MCU记录每个Socket发送缓存的大小到数组tx_size[]对应的元素值
000010  5d29              LDRB     r1,[r5,r4]
000012  f6417208          MOV      r2,#0x1f08
000016  eb021044          ADD      r0,r2,r4,LSL #5
00001a  f7fffffe          BL       IINCHIP_WRITE
;;;157              IINCHIP_WRITE( (Sn_RXMEM_SIZE(i)), rx_size[i]);		// MCU记录每个Socket接收缓存的大小到数组rx_size[]对应的元素值
00001e  5d31              LDRB     r1,[r6,r4]
000020  f6416208          MOV      r2,#0x1e08
000024  eb021044          ADD      r0,r2,r4,LSL #5
000028  f7fffffe          BL       IINCHIP_WRITE
;;;158              
;;;159    #ifdef __DEF_IINCHIP_DBG__
;;;160             printf("tx_size[%d]: %d, Sn_TXMEM_SIZE = %d\r\n",i, tx_size[i], IINCHIP_READ(Sn_TXMEM_SIZE(i)));
;;;161             printf("rx_size[%d]: %d, Sn_RXMEM_SIZE = %d\r\n",i, rx_size[i], IINCHIP_READ(Sn_RXMEM_SIZE(i)));
;;;162    #endif
;;;163        SSIZE[i] = (int16)(0);
00002c  2000              MOVS     r0,#0
00002e  4940              LDR      r1,|L35.304|
000030  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;164        RSIZE[i] = (int16)(0);
000034  493f              LDR      r1,|L35.308|
000036  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;165    
;;;166    
;;;167        if (ssum <= 16384)
00003a  f5b74f80          CMP      r7,#0x4000
00003e  dc32              BGT      |L35.166|
;;;168        {
;;;169             switch( tx_size[i] )
000040  5d28              LDRB     r0,[r5,r4]
000042  2804              CMP      r0,#4
000044  d016              BEQ      |L35.116|
000046  dc04              BGT      |L35.82|
000048  2801              CMP      r0,#1
00004a  d007              BEQ      |L35.92|
00004c  2802              CMP      r0,#2
00004e  d123              BNE      |L35.152|
000050  e00a              B        |L35.104|
                  |L35.82|
000052  2808              CMP      r0,#8
000054  d014              BEQ      |L35.128|
000056  2810              CMP      r0,#0x10
000058  d11e              BNE      |L35.152|
00005a  e017              B        |L35.140|
                  |L35.92|
;;;170          {
;;;171          case 1:
;;;172            SSIZE[i] = (int16)(1024);
00005c  f44f6080          MOV      r0,#0x400
000060  4933              LDR      r1,|L35.304|
000062  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;173            break;
000066  e01d              B        |L35.164|
                  |L35.104|
;;;174          case 2:
;;;175            SSIZE[i] = (int16)(2048);
000068  f44f6000          MOV      r0,#0x800
00006c  4930              LDR      r1,|L35.304|
00006e  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;176            break;
000072  e017              B        |L35.164|
                  |L35.116|
;;;177          case 4:
;;;178            SSIZE[i] = (int16)(4096);
000074  f44f5080          MOV      r0,#0x1000
000078  492d              LDR      r1,|L35.304|
00007a  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;179            break;
00007e  e011              B        |L35.164|
                  |L35.128|
;;;180          case 8:
;;;181            SSIZE[i] = (int16)(8192);
000080  f44f5000          MOV      r0,#0x2000
000084  492a              LDR      r1,|L35.304|
000086  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;182            break;
00008a  e00b              B        |L35.164|
                  |L35.140|
;;;183          case 16:
;;;184            SSIZE[i] = (int16)(16384);
00008c  f44f4080          MOV      r0,#0x4000
000090  4927              LDR      r1,|L35.304|
000092  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;185          break;
000096  e005              B        |L35.164|
                  |L35.152|
;;;186          default :
;;;187            RSIZE[i] = (int16)(2048);
000098  f44f6000          MOV      r0,#0x800
00009c  4925              LDR      r1,|L35.308|
00009e  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;188            break;
0000a2  bf00              NOP      
                  |L35.164|
0000a4  bf00              NOP                            ;173
                  |L35.166|
;;;189          }
;;;190        }
;;;191    
;;;192       if (rsum <= 16384)
0000a6  f5b84f80          CMP      r8,#0x4000
0000aa  dc32              BGT      |L35.274|
;;;193        {
;;;194             switch( rx_size[i] )
0000ac  5d30              LDRB     r0,[r6,r4]
0000ae  2804              CMP      r0,#4
0000b0  d016              BEQ      |L35.224|
0000b2  dc04              BGT      |L35.190|
0000b4  2801              CMP      r0,#1
0000b6  d007              BEQ      |L35.200|
0000b8  2802              CMP      r0,#2
0000ba  d123              BNE      |L35.260|
0000bc  e00a              B        |L35.212|
                  |L35.190|
0000be  2808              CMP      r0,#8
0000c0  d014              BEQ      |L35.236|
0000c2  2810              CMP      r0,#0x10
0000c4  d11e              BNE      |L35.260|
0000c6  e017              B        |L35.248|
                  |L35.200|
;;;195          {
;;;196          case 1:
;;;197            RSIZE[i] = (int16)(1024);
0000c8  f44f6080          MOV      r0,#0x400
0000cc  4919              LDR      r1,|L35.308|
0000ce  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;198            break;
0000d2  e01d              B        |L35.272|
                  |L35.212|
;;;199          case 2:
;;;200            RSIZE[i] = (int16)(2048);
0000d4  f44f6000          MOV      r0,#0x800
0000d8  4916              LDR      r1,|L35.308|
0000da  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;201            break;
0000de  e017              B        |L35.272|
                  |L35.224|
;;;202          case 4:
;;;203            RSIZE[i] = (int16)(4096);
0000e0  f44f5080          MOV      r0,#0x1000
0000e4  4913              LDR      r1,|L35.308|
0000e6  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;204            break;
0000ea  e011              B        |L35.272|
                  |L35.236|
;;;205          case 8:
;;;206            RSIZE[i] = (int16)(8192);
0000ec  f44f5000          MOV      r0,#0x2000
0000f0  4910              LDR      r1,|L35.308|
0000f2  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;207            break;
0000f6  e00b              B        |L35.272|
                  |L35.248|
;;;208          case 16:
;;;209            RSIZE[i] = (int16)(16384);
0000f8  f44f4080          MOV      r0,#0x4000
0000fc  490d              LDR      r1,|L35.308|
0000fe  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;210            break;
000102  e005              B        |L35.272|
                  |L35.260|
;;;211          default :
;;;212            RSIZE[i] = (int16)(2048);
000104  f44f6000          MOV      r0,#0x800
000108  490a              LDR      r1,|L35.308|
00010a  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;213            break;
00010e  bf00              NOP      
                  |L35.272|
000110  bf00              NOP                            ;198
                  |L35.274|
;;;214          }
;;;215        }
;;;216        ssum += SSIZE[i];
000112  4807              LDR      r0,|L35.304|
000114  f8300014          LDRH     r0,[r0,r4,LSL #1]
000118  4407              ADD      r7,r7,r0
;;;217        rsum += RSIZE[i];
00011a  4806              LDR      r0,|L35.308|
00011c  f8300014          LDRH     r0,[r0,r4,LSL #1]
000120  4480              ADD      r8,r8,r0
000122  1c64              ADDS     r4,r4,#1              ;154
                  |L35.292|
000124  2c08              CMP      r4,#8                 ;154
000126  f6ffaf73          BLT      |L35.16|
;;;218    
;;;219      }
;;;220    }
00012a  e8bd81f0          POP      {r4-r8,pc}
;;;221    
                          ENDP

00012e  0000              DCW      0x0000
                  |L35.304|
                          DCD      SSIZE
                  |L35.308|
                          DCD      RSIZE

                          AREA ||i.wiz_read_buf||, CODE, READONLY, ALIGN=2

                  wiz_read_buf PROC
;;;87     
;;;88     uint16 wiz_read_buf(uint32 addrbsb, uint8* buf,uint16 len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;89     {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;90       uint16 idx = 0;
00000a  2600              MOVS     r6,#0
;;;91       if(len == 0)
00000c  b915              CBNZ     r5,|L36.20|
;;;92       {
;;;93         printf("Unexpected2 length 0\r\n");
00000e  a010              ADR      r0,|L36.80|
000010  f7fffffe          BL       __2printf
                  |L36.20|
;;;94       }
;;;95     
;;;96       //IINCHIP_ISR_DISABLE();
;;;97       //SPI MODE I/F
;;;98       IINCHIP_CSoff();                                  // CS=0, SPI start
000014  f7fffffe          BL       IINCHIP_CSoff
;;;99       IINCHIP_SpiSendData( (addrbsb & 0x00FF0000)>>16);// Address byte 1
000018  f3c44007          UBFX     r0,r4,#16,#8
00001c  f7fffffe          BL       IINCHIP_SpiSendData
;;;100      IINCHIP_SpiSendData( (addrbsb & 0x0000FF00)>> 8);// Address byte 2
000020  f3c42007          UBFX     r0,r4,#8,#8
000024  f7fffffe          BL       IINCHIP_SpiSendData
;;;101      IINCHIP_SpiSendData( (addrbsb & 0x000000F8));    // Data write command and Write data length 1
000028  f00400f8          AND      r0,r4,#0xf8
00002c  f7fffffe          BL       IINCHIP_SpiSendData
;;;102      for(idx = 0; idx < len; idx++)                    // Write data in loop
000030  2600              MOVS     r6,#0
000032  e005              B        |L36.64|
                  |L36.52|
;;;103      {
;;;104        buf[idx] = IINCHIP_SpiSendData(0x00);
000034  2000              MOVS     r0,#0
000036  f7fffffe          BL       IINCHIP_SpiSendData
00003a  55b8              STRB     r0,[r7,r6]
00003c  1c70              ADDS     r0,r6,#1              ;102
00003e  b286              UXTH     r6,r0                 ;102
                  |L36.64|
000040  42ae              CMP      r6,r5                 ;102
000042  dbf7              BLT      |L36.52|
;;;105      }
;;;106      IINCHIP_CSon();                                   // CS=1, SPI end
000044  f7fffffe          BL       IINCHIP_CSon
;;;107      //IINCHIP_ISR_ENABLE();                             // Interrupt Service Routine Enable
;;;108      
;;;109      return len;
000048  4628              MOV      r0,r5
;;;110    }
00004a  e8bd81f0          POP      {r4-r8,pc}
;;;111    
                          ENDP

00004e  0000              DCW      0x0000
                  |L36.80|
000050  556e6578          DCB      "Unexpected2 length 0\r\n",0
000054  70656374
000058  65643220
00005c  6c656e67
000060  74682030
000064  0d0a00  
000067  00                DCB      0

                          AREA ||i.wiz_write_buf||, CODE, READONLY, ALIGN=2

                  wiz_write_buf PROC
;;;67     
;;;68     uint16 wiz_write_buf(uint32 addrbsb,uint8* buf,uint16 len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;69     {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;70        uint16 idx = 0;
00000a  2600              MOVS     r6,#0
;;;71        if(len == 0) printf("Unexpected2 length 0\r\n");
00000c  b915              CBNZ     r5,|L37.20|
00000e  a010              ADR      r0,|L37.80|
000010  f7fffffe          BL       __2printf
                  |L37.20|
;;;72     
;;;73        //IINCHIP_ISR_DISABLE();
;;;74        IINCHIP_CSoff();                              // CS=0, SPI start
000014  f7fffffe          BL       IINCHIP_CSoff
;;;75        IINCHIP_SpiSendData( (addrbsb & 0x00FF0000)>>16);// Address byte 1
000018  f3c44007          UBFX     r0,r4,#16,#8
00001c  f7fffffe          BL       IINCHIP_SpiSendData
;;;76        IINCHIP_SpiSendData( (addrbsb & 0x0000FF00)>> 8);// Address byte 2
000020  f3c42007          UBFX     r0,r4,#8,#8
000024  f7fffffe          BL       IINCHIP_SpiSendData
;;;77        IINCHIP_SpiSendData( (addrbsb & 0x000000F8) + 4);    // Data write command and Write data length 1
000028  f00401f8          AND      r1,r4,#0xf8
00002c  1d09              ADDS     r1,r1,#4
00002e  b2c8              UXTB     r0,r1
000030  f7fffffe          BL       IINCHIP_SpiSendData
;;;78        for(idx = 0; idx < len; idx++)                // Write data in loop
000034  2600              MOVS     r6,#0
000036  e004              B        |L37.66|
                  |L37.56|
;;;79        {
;;;80          IINCHIP_SpiSendData(buf[idx]);
000038  5db8              LDRB     r0,[r7,r6]
00003a  f7fffffe          BL       IINCHIP_SpiSendData
00003e  1c70              ADDS     r0,r6,#1              ;78
000040  b286              UXTH     r6,r0                 ;78
                  |L37.66|
000042  42ae              CMP      r6,r5                 ;78
000044  dbf8              BLT      |L37.56|
;;;81        }
;;;82        IINCHIP_CSon();                               // CS=1, SPI end
000046  f7fffffe          BL       IINCHIP_CSon
;;;83        //IINCHIP_ISR_ENABLE();                         // Interrupt Service Routine Enable    
;;;84     
;;;85        return len;  
00004a  4628              MOV      r0,r5
;;;86     }
00004c  e8bd81f0          POP      {r4-r8,pc}
;;;87     
                          ENDP

                  |L37.80|
000050  556e6578          DCB      "Unexpected2 length 0\r\n",0
000054  70656374
000058  65643220
00005c  6c656e67
000060  74682030
000064  0d0a00  
000067  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  SSIZE
                          %        16
                  RSIZE
                          %        16

                          AREA ||.data||, DATA, ALIGN=0

                  I_STATUS
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\Net\\w5500.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___7_w5500_c_getISR____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___7_w5500_c_getISR____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___7_w5500_c_getISR____REVSH|
#line 128
|__asm___7_w5500_c_getISR____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
