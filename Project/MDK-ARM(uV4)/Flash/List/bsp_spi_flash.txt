; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_spi_flash.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_spi_flash.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\RTX\inc -I..\..\RTX\portable -I..\..\User\CpuFlash -I..\..\User\CRC8_16 -I..\..\User\DS1302 -I..\..\User\DWT -I..\..\User\IIC -I..\..\User\IWDG -I..\..\User\Key -I..\..\User\Led -I..\..\User\Net -I..\..\User\Protocal -I..\..\User\Reader -I..\..\User\SPI -I..\..\User\Timer -I..\..\User\Uart -I..\..\User\Param -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_spi_flash.crf ..\..\User\SPI\bsp_spi_flash.c]
                          THUMB

                          AREA ||i.bsp_InitSFlash||, CODE, READONLY, ALIGN=1

                  bsp_InitSFlash PROC
;;;166    */
;;;167    void bsp_InitSFlash(void)
000000  b510              PUSH     {r4,lr}
;;;168    {
;;;169    	sf_ConfigGPIO();			/* 配置GPIO */
000002  f7fffffe          BL       sf_ConfigGPIO
;;;170    	
;;;171    	//sf_CfgSpiHard();//已经在spibus中完成
;;;172    
;;;173    	sf_ReadInfo();				/* 自动识别芯片型号 */
000006  f7fffffe          BL       sf_ReadInfo
;;;174    
;;;175    	sf_SetCS(0);				/* 软件方式，使能串行Flash片选 */
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       sf_SetCS
;;;176    	bsp_spiWrite1(CMD_DISWR);		/* 发送禁止写入的命令,即使能软件写保护 */
000010  2004              MOVS     r0,#4
000012  f7fffffe          BL       bsp_spiWrite1
;;;177    	sf_SetCS(1);				/* 软件方式，禁能串行Flash片选 */
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       sf_SetCS
;;;178    
;;;179    	sf_WaitForWriteEnd();		/* 等待串行Flash内部操作完成 */
00001c  f7fffffe          BL       sf_WaitForWriteEnd
;;;180    
;;;181    	sf_WriteStatus(0);			/* 解除所有BLOCK的写保护 */
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       sf_WriteStatus
;;;182    }
000026  bd10              POP      {r4,pc}
;;;183    
                          ENDP


                          AREA ||i.sf_AutoWritePage||, CODE, READONLY, ALIGN=2

                  sf_AutoWritePage PROC
;;;442    */
;;;443    static uint8_t sf_AutoWritePage(uint8_t *_ucpSrc, uint32_t _uiWrAddr, uint16_t _usWrLen)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;444    {
000004  b081              SUB      sp,sp,#4
000006  f5ad5d80          SUB      sp,sp,#0x1000
00000a  4607              MOV      r7,r0
00000c  460d              MOV      r5,r1
00000e  4616              MOV      r6,r2
;;;445    	uint16_t i;
;;;446    	uint16_t j;					/* 用于延时 */
;;;447    	uint32_t uiFirstAddr;		/* 扇区首址 */
;;;448    	uint8_t ucNeedErase;		/* 1表示需要擦除 */
;;;449    	uint8_t cRet;
;;;450    	uint8_t s_spiBuf[4*1024];	/* 用于写函数，先读出整个page，修改缓冲区后，再整个page回写 */	
;;;451    
;;;452    	/* 长度为0时不继续操作,直接认为成功 */
;;;453    	if (_usWrLen == 0)
000010  b92e              CBNZ     r6,|L2.30|
;;;454    	{
;;;455    		return 1;
000012  2001              MOVS     r0,#1
                  |L2.20|
;;;456    	}
;;;457    
;;;458    	/* 如果偏移地址超过芯片容量则退出 */
;;;459    	if (_uiWrAddr >= g_tSF.TotalSize)
;;;460    	{
;;;461    		return 0;
;;;462    	}
;;;463    
;;;464    	/* 如果数据长度大于扇区容量，则退出 */
;;;465    	if (_usWrLen > g_tSF.PageSize)
;;;466    	{
;;;467    		return 0;
;;;468    	}
;;;469    
;;;470    	/* 如果FLASH中的数据没有变化,则不写FLASH */
;;;471    	sf_ReadBuffer(s_spiBuf, _uiWrAddr, _usWrLen);
;;;472    	if (memcmp(s_spiBuf, _ucpSrc, _usWrLen) == 0)
;;;473    	{
;;;474    		return 1;
;;;475    	}
;;;476    
;;;477    	/* 判断是否需要先擦除扇区 */
;;;478    	/* 如果旧数据修改为新数据，所有位均是 1->0 或者 0->0, 则无需擦除,提高Flash寿命 */
;;;479    	ucNeedErase = 0;
;;;480    	if (sf_NeedErase(s_spiBuf, _ucpSrc, _usWrLen))
;;;481    	{
;;;482    		ucNeedErase = 1;
;;;483    	}
;;;484    
;;;485    	uiFirstAddr = _uiWrAddr & (~(g_tSF.PageSize - 1));
;;;486    
;;;487    	if (_usWrLen == g_tSF.PageSize)		/* 整个扇区都改写 */
;;;488    	{
;;;489    		for	(i = 0; i < g_tSF.PageSize; i++)
;;;490    		{
;;;491    			s_spiBuf[i] = _ucpSrc[i];
;;;492    		}
;;;493    	}
;;;494    	else						/* 改写部分数据 */
;;;495    	{
;;;496    		/* 先将整个扇区的数据读出 */
;;;497    		sf_ReadBuffer(s_spiBuf, uiFirstAddr, g_tSF.PageSize);
;;;498    
;;;499    		/* 再用新数据覆盖 */
;;;500    		i = _uiWrAddr & (g_tSF.PageSize - 1);
;;;501    		memcpy(&s_spiBuf[i], _ucpSrc, _usWrLen);
;;;502    	}
;;;503    
;;;504    	/* 写完之后进行校验，如果不正确则重写，最多3次 */
;;;505    	cRet = 0;
;;;506    	for (i = 0; i < 3; i++)
;;;507    	{
;;;508    
;;;509    		/* 如果旧数据修改为新数据，所有位均是 1->0 或者 0->0, 则无需擦除,提高Flash寿命 */
;;;510    		if (ucNeedErase == 1)
;;;511    		{
;;;512    			sf_EraseSector(uiFirstAddr);		/* 擦除1个扇区 */
;;;513    		}
;;;514    
;;;515    		/* 编程一个PAGE */
;;;516    		sf_PageWrite(s_spiBuf, uiFirstAddr, g_tSF.PageSize);
;;;517    
;;;518    		if (sf_CmpData(_uiWrAddr, _ucpSrc, _usWrLen) == 0)
;;;519    		{
;;;520    			cRet = 1;
;;;521    			break;
;;;522    		}
;;;523    		else
;;;524    		{
;;;525    			if (sf_CmpData(_uiWrAddr, _ucpSrc, _usWrLen) == 0)
;;;526    			{
;;;527    				cRet = 1;
;;;528    				break;
;;;529    			}
;;;530    
;;;531    			/* 失败后延迟一段时间再重试 */
;;;532    			for (j = 0; j < 10000; j++);
;;;533    		}
;;;534    	}
;;;535    
;;;536    	return cRet;
;;;537    }
000014  b001              ADD      sp,sp,#4
000016  f50d5d80          ADD      sp,sp,#0x1000
00001a  e8bd8ff0          POP      {r4-r11,pc}
                  |L2.30|
00001e  483e              LDR      r0,|L2.280|
000020  6940              LDR      r0,[r0,#0x14]         ;459  ; g_tSF
000022  42a8              CMP      r0,r5                 ;459
000024  d801              BHI      |L2.42|
000026  2000              MOVS     r0,#0                 ;461
000028  e7f4              B        |L2.20|
                  |L2.42|
00002a  483b              LDR      r0,|L2.280|
00002c  8b00              LDRH     r0,[r0,#0x18]         ;465  ; g_tSF
00002e  42b0              CMP      r0,r6                 ;465
000030  da01              BGE      |L2.54|
000032  2000              MOVS     r0,#0                 ;467
000034  e7ee              B        |L2.20|
                  |L2.54|
000036  4632              MOV      r2,r6                 ;471
000038  4629              MOV      r1,r5                 ;471
00003a  a801              ADD      r0,sp,#4              ;471
00003c  f7fffffe          BL       sf_ReadBuffer
000040  4632              MOV      r2,r6                 ;472
000042  4639              MOV      r1,r7                 ;472
000044  a801              ADD      r0,sp,#4              ;472
000046  f7fffffe          BL       memcmp
00004a  b908              CBNZ     r0,|L2.80|
00004c  2001              MOVS     r0,#1                 ;474
00004e  e7e1              B        |L2.20|
                  |L2.80|
000050  f04f0a00          MOV      r10,#0                ;479
000054  4632              MOV      r2,r6                 ;480
000056  4639              MOV      r1,r7                 ;480
000058  a801              ADD      r0,sp,#4              ;480
00005a  f7fffffe          BL       sf_NeedErase
00005e  b108              CBZ      r0,|L2.100|
000060  f04f0a01          MOV      r10,#1                ;482
                  |L2.100|
000064  482c              LDR      r0,|L2.280|
000066  8b00              LDRH     r0,[r0,#0x18]         ;485  ; g_tSF
000068  1e40              SUBS     r0,r0,#1              ;485
00006a  ea250800          BIC      r8,r5,r0              ;485
00006e  482a              LDR      r0,|L2.280|
000070  8b00              LDRH     r0,[r0,#0x18]         ;487  ; g_tSF
000072  42b0              CMP      r0,r6                 ;487
000074  d10b              BNE      |L2.142|
000076  2400              MOVS     r4,#0                 ;489
000078  e004              B        |L2.132|
                  |L2.122|
00007a  5d38              LDRB     r0,[r7,r4]            ;491
00007c  a901              ADD      r1,sp,#4              ;491
00007e  5508              STRB     r0,[r1,r4]            ;491
000080  1c60              ADDS     r0,r4,#1              ;489
000082  b284              UXTH     r4,r0                 ;489
                  |L2.132|
000084  4824              LDR      r0,|L2.280|
000086  8b00              LDRH     r0,[r0,#0x18]         ;489  ; g_tSF
000088  42a0              CMP      r0,r4                 ;489
00008a  dcf6              BGT      |L2.122|
00008c  e010              B        |L2.176|
                  |L2.142|
00008e  4822              LDR      r0,|L2.280|
000090  8b02              LDRH     r2,[r0,#0x18]         ;497  ; g_tSF
000092  4641              MOV      r1,r8                 ;497
000094  a801              ADD      r0,sp,#4              ;497
000096  f7fffffe          BL       sf_ReadBuffer
00009a  481f              LDR      r0,|L2.280|
00009c  8b00              LDRH     r0,[r0,#0x18]         ;500  ; g_tSF
00009e  1e40              SUBS     r0,r0,#1              ;500
0000a0  4028              ANDS     r0,r0,r5              ;500
0000a2  b284              UXTH     r4,r0                 ;500
0000a4  a901              ADD      r1,sp,#4              ;501
0000a6  1908              ADDS     r0,r1,r4              ;501
0000a8  4632              MOV      r2,r6                 ;501
0000aa  4639              MOV      r1,r7                 ;501
0000ac  f7fffffe          BL       __aeabi_memcpy
                  |L2.176|
0000b0  f04f0b00          MOV      r11,#0                ;505
0000b4  2400              MOVS     r4,#0                 ;506
0000b6  e02a              B        |L2.270|
                  |L2.184|
0000b8  f1ba0f01          CMP      r10,#1                ;510
0000bc  d102              BNE      |L2.196|
0000be  4640              MOV      r0,r8                 ;512
0000c0  f7fffffe          BL       sf_EraseSector
                  |L2.196|
0000c4  4814              LDR      r0,|L2.280|
0000c6  8b02              LDRH     r2,[r0,#0x18]         ;516  ; g_tSF
0000c8  4641              MOV      r1,r8                 ;516
0000ca  a801              ADD      r0,sp,#4              ;516
0000cc  f7fffffe          BL       sf_PageWrite
0000d0  4632              MOV      r2,r6                 ;518
0000d2  4639              MOV      r1,r7                 ;518
0000d4  4628              MOV      r0,r5                 ;518
0000d6  f7fffffe          BL       sf_CmpData
0000da  b910              CBNZ     r0,|L2.226|
0000dc  f04f0b01          MOV      r11,#1                ;520
0000e0  e017              B        |L2.274|
                  |L2.226|
0000e2  4632              MOV      r2,r6                 ;525
0000e4  4639              MOV      r1,r7                 ;525
0000e6  4628              MOV      r0,r5                 ;525
0000e8  f7fffffe          BL       sf_CmpData
0000ec  b910              CBNZ     r0,|L2.244|
0000ee  f04f0b01          MOV      r11,#1                ;527
0000f2  e00e              B        |L2.274|
                  |L2.244|
0000f4  f04f0900          MOV      r9,#0                 ;532
0000f8  e003              B        |L2.258|
                  |L2.250|
0000fa  f1090001          ADD      r0,r9,#1              ;532
0000fe  fa1ff980          UXTH     r9,r0                 ;532
                  |L2.258|
000102  f2427010          MOV      r0,#0x2710            ;532
000106  4581              CMP      r9,r0                 ;532
000108  dbf7              BLT      |L2.250|
00010a  1c60              ADDS     r0,r4,#1              ;506
00010c  b284              UXTH     r4,r0                 ;506
                  |L2.270|
00010e  2c03              CMP      r4,#3                 ;506
000110  dbd2              BLT      |L2.184|
                  |L2.274|
000112  bf00              NOP                            ;521
000114  4658              MOV      r0,r11                ;536
000116  e77d              B        |L2.20|
;;;538    
                          ENDP

                  |L2.280|
                          DCD      g_tSF

                          AREA ||i.sf_CfgSpiHard||, CODE, READONLY, ALIGN=2

                  sf_CfgSpiHard PROC
;;;98     */
;;;99     void sf_CfgSpiHard(void)
000000  b500              PUSH     {lr}
;;;100    {
000002  b085              SUB      sp,sp,#0x14
;;;101    	SPI_InitTypeDef  SPI_InitStructure;
;;;102    
;;;103    	/* 配置SPI硬件参数 */
;;;104    	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;	/* 数据方向：2线全双工 */
000004  2000              MOVS     r0,#0
000006  f8ad0000          STRH     r0,[sp,#0]
;;;105    	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		/* STM32的SPI工作模式 ：主机模式 */
00000a  f44f7082          MOV      r0,#0x104
00000e  f8ad0002          STRH     r0,[sp,#2]
;;;106    	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;	/* 数据位长度 ： 8位 */
000012  2000              MOVS     r0,#0
000014  f8ad0004          STRH     r0,[sp,#4]
;;;107    	/* SPI_CPOL和SPI_CPHA结合使用决定时钟和数据采样点的相位关系、
;;;108    	   本例配置: 总线空闲是高电平,第2个边沿（上升沿采样数据)
;;;109    	*/
;;;110    	SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;			/* 时钟上升沿采样数据 */
000018  2002              MOVS     r0,#2
00001a  f8ad0006          STRH     r0,[sp,#6]
;;;111    	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;		/* 时钟的第2个边沿采样数据 */
00001e  2001              MOVS     r0,#1
000020  f8ad0008          STRH     r0,[sp,#8]
;;;112    	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;			/* 片选控制方式：软件控制 */
000024  0240              LSLS     r0,r0,#9
000026  f8ad000a          STRH     r0,[sp,#0xa]
;;;113    
;;;114    	/* 设置波特率预分频系数 SPI_BaudRatePrescaler_8 ，实测SCK周期 96ns, 10.4MHz */
;;;115    	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
00002a  2010              MOVS     r0,#0x10
00002c  f8ad000c          STRH     r0,[sp,#0xc]
;;;116    
;;;117    	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;	/* 数据位传输次序：高位先传 */
000030  2000              MOVS     r0,#0
000032  f8ad000e          STRH     r0,[sp,#0xe]
;;;118    	SPI_InitStructure.SPI_CRCPolynomial = 7;			/* CRC多项式寄存器，复位后为7。本例程不用 */
000036  2007              MOVS     r0,#7
000038  f8ad0010          STRH     r0,[sp,#0x10]
;;;119    	SPI_Init(SPI1, &SPI_InitStructure);
00003c  4669              MOV      r1,sp
00003e  4804              LDR      r0,|L3.80|
000040  f7fffffe          BL       SPI_Init
;;;120    
;;;121    	SPI_Cmd(SPI1, ENABLE);				/* 使能SPI  */
000044  2101              MOVS     r1,#1
000046  4802              LDR      r0,|L3.80|
000048  f7fffffe          BL       SPI_Cmd
;;;122    }
00004c  b005              ADD      sp,sp,#0x14
00004e  bd00              POP      {pc}
;;;123    
                          ENDP

                  |L3.80|
                          DCD      0x40013000

                          AREA ||i.sf_CmpData||, CODE, READONLY, ALIGN=2

                  sf_CmpData PROC
;;;354    */
;;;355    static uint8_t sf_CmpData(uint32_t _uiSrcAddr, uint8_t *_ucpTar, uint32_t _uiSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;356    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;357    	uint8_t ucValue;
;;;358    
;;;359    	/* 如果读取的数据长度为0或者超出串行Flash地址空间，则直接返回 */
;;;360    	if ((_uiSrcAddr + _uiSize) > g_tSF.TotalSize)
00000a  1960              ADDS     r0,r4,r5
00000c  4918              LDR      r1,|L4.112|
00000e  6949              LDR      r1,[r1,#0x14]  ; g_tSF
000010  4288              CMP      r0,r1
000012  d902              BLS      |L4.26|
;;;361    	{
;;;362    		return 1;
000014  2001              MOVS     r0,#1
                  |L4.22|
;;;363    	}
;;;364    
;;;365    	if (_uiSize == 0)
;;;366    	{
;;;367    		return 0;
;;;368    	}
;;;369    
;;;370    	sf_SetCS(0);									/* 使能片选 */
;;;371    	bsp_spiWrite1(CMD_READ);							/* 发送读命令 */
;;;372    	bsp_spiWrite1((_uiSrcAddr & 0xFF0000) >> 16);		/* 发送扇区地址的高8bit */
;;;373    	bsp_spiWrite1((_uiSrcAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
;;;374    	bsp_spiWrite1(_uiSrcAddr & 0xFF);					/* 发送扇区地址低8bit */
;;;375    	while (_uiSize--)
;;;376    	{
;;;377    		/* 读一个字节 */
;;;378    		ucValue = bsp_spiRead1();
;;;379    		if (*_ucpTar++ != ucValue)
;;;380    		{
;;;381    			sf_SetCS(1);
;;;382    			return 1;
;;;383    		}
;;;384    	}
;;;385    	sf_SetCS(1);
;;;386    	return 0;
;;;387    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L4.26|
00001a  b90d              CBNZ     r5,|L4.32|
00001c  2000              MOVS     r0,#0                 ;367
00001e  e7fa              B        |L4.22|
                  |L4.32|
000020  2000              MOVS     r0,#0                 ;370
000022  f7fffffe          BL       sf_SetCS
000026  2003              MOVS     r0,#3                 ;371
000028  f7fffffe          BL       bsp_spiWrite1
00002c  f3c44007          UBFX     r0,r4,#16,#8          ;372
000030  f7fffffe          BL       bsp_spiWrite1
000034  f3c42007          UBFX     r0,r4,#8,#8           ;373
000038  f7fffffe          BL       bsp_spiWrite1
00003c  b2e0              UXTB     r0,r4                 ;374
00003e  f7fffffe          BL       bsp_spiWrite1
000042  e00b              B        |L4.92|
                  |L4.68|
000044  f7fffffe          BL       bsp_spiRead1
000048  4607              MOV      r7,r0                 ;378
00004a  f8161b01          LDRB     r1,[r6],#1            ;379
00004e  42b9              CMP      r1,r7                 ;379
000050  d004              BEQ      |L4.92|
000052  2001              MOVS     r0,#1                 ;381
000054  f7fffffe          BL       sf_SetCS
000058  2001              MOVS     r0,#1                 ;382
00005a  e7dc              B        |L4.22|
                  |L4.92|
00005c  0028              MOVS     r0,r5                 ;375
00005e  f1a50501          SUB      r5,r5,#1              ;375
000062  d1ef              BNE      |L4.68|
000064  2001              MOVS     r0,#1                 ;385
000066  f7fffffe          BL       sf_SetCS
00006a  2000              MOVS     r0,#0                 ;386
00006c  e7d3              B        |L4.22|
;;;388    
                          ENDP

00006e  0000              DCW      0x0000
                  |L4.112|
                          DCD      g_tSF

                          AREA ||i.sf_ConfigGPIO||, CODE, READONLY, ALIGN=2

                  sf_ConfigGPIO PROC
;;;71     */
;;;72     static void sf_ConfigGPIO(void)
000000  b508              PUSH     {r3,lr}
;;;73     {
;;;74     	/*
;;;75     		安富莱STM32-V4 开发板口线分配：  串行Flash型号为 W25Q64BVSSIG (80MHz)
;;;76     		PF8/SF_CS
;;;77     	*/
;;;78     	GPIO_InitTypeDef GPIO_InitStructure;
;;;79     
;;;80     	/* 使能GPIO 时钟 */
;;;81     	RCC_APB2PeriphClockCmd(SF_RCC_CS, ENABLE);
000002  2101              MOVS     r1,#1
000004  2010              MOVS     r0,#0x10
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;82     
;;;83     	/* 配置片选口线为推挽输出模式 */
;;;84     	sf_SetCS(1);		/* 片选置高，不选中 */
00000a  2001              MOVS     r0,#1
00000c  f7fffffe          BL       sf_SetCS
;;;85     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
;;;86     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000016  2003              MOVS     r0,#3
000018  f88d0002          STRB     r0,[sp,#2]
;;;87     	GPIO_InitStructure.GPIO_Pin = SF_PIN_CS;
00001c  2010              MOVS     r0,#0x10
00001e  f8ad0000          STRH     r0,[sp,#0]
;;;88     	GPIO_Init(SF_PORT_CS, &GPIO_InitStructure);
000022  4669              MOV      r1,sp
000024  4801              LDR      r0,|L5.44|
000026  f7fffffe          BL       GPIO_Init
;;;89     }
00002a  bd08              POP      {r3,pc}
;;;90     
                          ENDP

                  |L5.44|
                          DCD      0x40011000

                          AREA ||i.sf_EraseChip||, CODE, READONLY, ALIGN=1

                  sf_EraseChip PROC
;;;214    */
;;;215    void sf_EraseChip(void)
000000  b510              PUSH     {r4,lr}
;;;216    {
;;;217    	sf_WriteEnable();								/* 发送写使能命令 */
000002  f7fffffe          BL       sf_WriteEnable
;;;218    
;;;219    	/* 擦除扇区操作 */
;;;220    	sf_SetCS(0);									/* 使能片选 */
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       sf_SetCS
;;;221    	bsp_spiWrite1(CMD_BE);							/* 发送整片擦除命令 */
00000c  20c7              MOVS     r0,#0xc7
00000e  f7fffffe          BL       bsp_spiWrite1
;;;222    	sf_SetCS(1);									/* 禁能片选 */
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       sf_SetCS
;;;223    
;;;224    	sf_WaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */
000018  f7fffffe          BL       sf_WaitForWriteEnd
;;;225    }
00001c  bd10              POP      {r4,pc}
;;;226    
                          ENDP


                          AREA ||i.sf_EraseSector||, CODE, READONLY, ALIGN=1

                  sf_EraseSector PROC
;;;191    */
;;;192    void sf_EraseSector(uint32_t _uiSectorAddr)
000000  b510              PUSH     {r4,lr}
;;;193    {
000002  4604              MOV      r4,r0
;;;194    	sf_WriteEnable();								/* 发送写使能命令 */
000004  f7fffffe          BL       sf_WriteEnable
;;;195    
;;;196    	/* 擦除扇区操作 */
;;;197    	sf_SetCS(0);									/* 使能片选 */
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       sf_SetCS
;;;198    	bsp_spiWrite1(CMD_SE);								/* 发送擦除命令 */
00000e  2020              MOVS     r0,#0x20
000010  f7fffffe          BL       bsp_spiWrite1
;;;199    	bsp_spiWrite1((_uiSectorAddr & 0xFF0000) >> 16);	/* 发送扇区地址的高8bit */
000014  f3c44007          UBFX     r0,r4,#16,#8
000018  f7fffffe          BL       bsp_spiWrite1
;;;200    	bsp_spiWrite1((_uiSectorAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
00001c  f3c42007          UBFX     r0,r4,#8,#8
000020  f7fffffe          BL       bsp_spiWrite1
;;;201    	bsp_spiWrite1(_uiSectorAddr & 0xFF);				/* 发送扇区地址低8bit */
000024  b2e0              UXTB     r0,r4
000026  f7fffffe          BL       bsp_spiWrite1
;;;202    	sf_SetCS(1);									/* 禁能片选 */
00002a  2001              MOVS     r0,#1
00002c  f7fffffe          BL       sf_SetCS
;;;203    
;;;204    	sf_WaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */
000030  f7fffffe          BL       sf_WaitForWriteEnd
;;;205    }
000034  bd10              POP      {r4,pc}
;;;206    
                          ENDP


                          AREA ||i.sf_NeedErase||, CODE, READONLY, ALIGN=1

                  sf_NeedErase PROC
;;;398    */
;;;399    static uint8_t sf_NeedErase(uint8_t * _ucpOldBuf, uint8_t *_ucpNewBuf, uint16_t _usLen)
000000  b570              PUSH     {r4-r6,lr}
;;;400    {
000002  4603              MOV      r3,r0
;;;401    	uint16_t i;
;;;402    	uint8_t ucOld;
;;;403    
;;;404    	/*
;;;405    	算法第1步：old 求反, new 不变
;;;406    	      old    new
;;;407    		  1101   0101
;;;408    	~     1111
;;;409    		= 0010   0101
;;;410    
;;;411    	算法第2步: old 求反的结果与 new 位与
;;;412    		  0010   old
;;;413    	&	  0101   new
;;;414    		 =0000
;;;415    
;;;416    	算法第3步: 结果为0,则表示无需擦除. 否则表示需要擦除
;;;417    	*/
;;;418    
;;;419    	for (i = 0; i < _usLen; i++)
000004  2400              MOVS     r4,#0
000006  e00b              B        |L8.32|
                  |L8.8|
;;;420    	{
;;;421    		ucOld = *_ucpOldBuf++;
000008  f8135b01          LDRB     r5,[r3],#1
;;;422    		ucOld = ~ucOld;
00000c  43e8              MVNS     r0,r5
00000e  b2c5              UXTB     r5,r0
;;;423    
;;;424    		/* 注意错误的写法: if (ucOld & (*_ucpNewBuf++) != 0) */
;;;425    		if ((ucOld & (*_ucpNewBuf++)) != 0)
000010  f8110b01          LDRB     r0,[r1],#1
000014  4228              TST      r0,r5
000016  d001              BEQ      |L8.28|
;;;426    		{
;;;427    			return 1;
000018  2001              MOVS     r0,#1
                  |L8.26|
;;;428    		}
;;;429    	}
;;;430    	return 0;
;;;431    }
00001a  bd70              POP      {r4-r6,pc}
                  |L8.28|
00001c  1c60              ADDS     r0,r4,#1              ;419
00001e  b284              UXTH     r4,r0                 ;419
                  |L8.32|
000020  4294              CMP      r4,r2                 ;419
000022  dbf1              BLT      |L8.8|
000024  2000              MOVS     r0,#0                 ;430
000026  e7f8              B        |L8.26|
;;;432    
                          ENDP


                          AREA ||i.sf_PageWrite||, CODE, READONLY, ALIGN=2

                  sf_PageWrite PROC
;;;236    */
;;;237    void sf_PageWrite(uint8_t * _pBuf, uint32_t _uiWriteAddr, uint16_t _usSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;238    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;239    	uint32_t i, j;
;;;240    
;;;241    	if (g_tSF.ChipID == SST25VF016B_ID)
00000a  484a              LDR      r0,|L9.308|
00000c  6800              LDR      r0,[r0,#0]  ; g_tSF
00000e  494a              LDR      r1,|L9.312|
000010  4288              CMP      r0,r1
000012  d153              BNE      |L9.188|
;;;242    	{
;;;243    		/* AAI指令要求传入的数据个数是偶数 */
;;;244    		if ((_usSize < 2) && (_usSize % 2))
000014  2d02              CMP      r5,#2
000016  da08              BGE      |L9.42|
000018  4628              MOV      r0,r5
00001a  eb0571d0          ADD      r1,r5,r0,LSR #31
00001e  1049              ASRS     r1,r1,#1
000020  ebb50141          SUBS     r1,r5,r1,LSL #1
000024  d001              BEQ      |L9.42|
                  |L9.38|
;;;245    		{
;;;246    			return ;
;;;247    		}
;;;248    
;;;249    		sf_WriteEnable();								/* 发送写使能命令 */
;;;250    
;;;251    		sf_SetCS(0);									/* 使能片选 */
;;;252    		bsp_spiWrite1(CMD_AAI);							/* 发送AAI命令(地址自动增加编程) */
;;;253    		bsp_spiWrite1((_uiWriteAddr & 0xFF0000) >> 16);	/* 发送扇区地址的高8bit */
;;;254    		bsp_spiWrite1((_uiWriteAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
;;;255    		bsp_spiWrite1(_uiWriteAddr & 0xFF);				/* 发送扇区地址低8bit */
;;;256    		bsp_spiWrite1(*_pBuf++);							/* 发送第1个数据 */
;;;257    		bsp_spiWrite1(*_pBuf++);							/* 发送第2个数据 */
;;;258    		sf_SetCS(1);									/* 禁能片选 */
;;;259    
;;;260    		sf_WaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */
;;;261    
;;;262    		_usSize -= 2;									/* 计算剩余字节数 */
;;;263    
;;;264    		for (i = 0; i < _usSize / 2; i++)
;;;265    		{
;;;266    			sf_SetCS(0);								/* 使能片选 */
;;;267    			bsp_spiWrite1(CMD_AAI);						/* 发送AAI命令(地址自动增加编程) */
;;;268    			bsp_spiWrite1(*_pBuf++);						/* 发送数据 */
;;;269    			bsp_spiWrite1(*_pBuf++);						/* 发送数据 */
;;;270    			sf_SetCS(1);								/* 禁能片选 */
;;;271    			sf_WaitForWriteEnd();						/* 等待串行Flash内部写操作完成 */
;;;272    		}
;;;273    
;;;274    		/* 进入写保护状态 */
;;;275    		sf_SetCS(0);
;;;276    		bsp_spiWrite1(CMD_DISWR);
;;;277    		sf_SetCS(1);
;;;278    
;;;279    		sf_WaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */
;;;280    	}
;;;281    	else	/* for MX25L1606E 、 W25Q64BV */
;;;282    	{
;;;283    		for (j = 0; j < _usSize / 256; j++)
;;;284    		{
;;;285    			sf_WriteEnable();								/* 发送写使能命令 */
;;;286    
;;;287    			sf_SetCS(0);									/* 使能片选 */
;;;288    			bsp_spiWrite1(0x02);								/* 发送AAI命令(地址自动增加编程) */
;;;289    			bsp_spiWrite1((_uiWriteAddr & 0xFF0000) >> 16);	/* 发送扇区地址的高8bit */
;;;290    			bsp_spiWrite1((_uiWriteAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
;;;291    			bsp_spiWrite1(_uiWriteAddr & 0xFF);				/* 发送扇区地址低8bit */
;;;292    
;;;293    			for (i = 0; i < 256; i++)
;;;294    			{
;;;295    				bsp_spiWrite1(*_pBuf++);					/* 发送数据 */
;;;296    			}
;;;297    
;;;298    			sf_SetCS(1);								/* 禁止片选 */
;;;299    
;;;300    			sf_WaitForWriteEnd();						/* 等待串行Flash内部写操作完成 */
;;;301    
;;;302    			_uiWriteAddr += 256;
;;;303    		}
;;;304    
;;;305    		/* 进入写保护状态 */
;;;306    		sf_SetCS(0);
;;;307    		bsp_spiWrite1(CMD_DISWR);
;;;308    		sf_SetCS(1);
;;;309    
;;;310    		sf_WaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */
;;;311    	}
;;;312    }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L9.42|
00002a  f7fffffe          BL       sf_WriteEnable
00002e  2000              MOVS     r0,#0                 ;251
000030  f7fffffe          BL       sf_SetCS
000034  20ad              MOVS     r0,#0xad              ;252
000036  f7fffffe          BL       bsp_spiWrite1
00003a  f3c64007          UBFX     r0,r6,#16,#8          ;253
00003e  f7fffffe          BL       bsp_spiWrite1
000042  f3c62007          UBFX     r0,r6,#8,#8           ;254
000046  f7fffffe          BL       bsp_spiWrite1
00004a  b2f0              UXTB     r0,r6                 ;255
00004c  f7fffffe          BL       bsp_spiWrite1
000050  f8140b01          LDRB     r0,[r4],#1            ;256
000054  f7fffffe          BL       bsp_spiWrite1
000058  f8140b01          LDRB     r0,[r4],#1            ;257
00005c  f7fffffe          BL       bsp_spiWrite1
000060  2001              MOVS     r0,#1                 ;258
000062  f7fffffe          BL       sf_SetCS
000066  f7fffffe          BL       sf_WaitForWriteEnd
00006a  1ea8              SUBS     r0,r5,#2              ;262
00006c  b285              UXTH     r5,r0                 ;262
00006e  2700              MOVS     r7,#0                 ;264
000070  e013              B        |L9.154|
                  |L9.114|
000072  2000              MOVS     r0,#0                 ;266
000074  f7fffffe          BL       sf_SetCS
000078  20ad              MOVS     r0,#0xad              ;267
00007a  f7fffffe          BL       bsp_spiWrite1
00007e  f8140b01          LDRB     r0,[r4],#1            ;268
000082  f7fffffe          BL       bsp_spiWrite1
000086  f8140b01          LDRB     r0,[r4],#1            ;269
00008a  f7fffffe          BL       bsp_spiWrite1
00008e  2001              MOVS     r0,#1                 ;270
000090  f7fffffe          BL       sf_SetCS
000094  f7fffffe          BL       sf_WaitForWriteEnd
000098  1c7f              ADDS     r7,r7,#1              ;264
                  |L9.154|
00009a  eb0571d5          ADD      r1,r5,r5,LSR #31      ;264
00009e  ebb70f61          CMP      r7,r1,ASR #1          ;264
0000a2  d3e6              BCC      |L9.114|
0000a4  2000              MOVS     r0,#0                 ;275
0000a6  f7fffffe          BL       sf_SetCS
0000aa  2004              MOVS     r0,#4                 ;276
0000ac  f7fffffe          BL       bsp_spiWrite1
0000b0  2001              MOVS     r0,#1                 ;277
0000b2  f7fffffe          BL       sf_SetCS
0000b6  f7fffffe          BL       sf_WaitForWriteEnd
0000ba  e038              B        |L9.302|
                  |L9.188|
0000bc  f04f0800          MOV      r8,#0                 ;283
0000c0  e024              B        |L9.268|
                  |L9.194|
0000c2  f7fffffe          BL       sf_WriteEnable
0000c6  2000              MOVS     r0,#0                 ;287
0000c8  f7fffffe          BL       sf_SetCS
0000cc  2002              MOVS     r0,#2                 ;288
0000ce  f7fffffe          BL       bsp_spiWrite1
0000d2  f3c64007          UBFX     r0,r6,#16,#8          ;289
0000d6  f7fffffe          BL       bsp_spiWrite1
0000da  f3c62007          UBFX     r0,r6,#8,#8           ;290
0000de  f7fffffe          BL       bsp_spiWrite1
0000e2  b2f0              UXTB     r0,r6                 ;291
0000e4  f7fffffe          BL       bsp_spiWrite1
0000e8  2700              MOVS     r7,#0                 ;293
0000ea  e004              B        |L9.246|
                  |L9.236|
0000ec  f8140b01          LDRB     r0,[r4],#1            ;295
0000f0  f7fffffe          BL       bsp_spiWrite1
0000f4  1c7f              ADDS     r7,r7,#1              ;293
                  |L9.246|
0000f6  2fff              CMP      r7,#0xff              ;293
0000f8  d9f8              BLS      |L9.236|
0000fa  2001              MOVS     r0,#1                 ;298
0000fc  f7fffffe          BL       sf_SetCS
000100  f7fffffe          BL       sf_WaitForWriteEnd
000104  f5067680          ADD      r6,r6,#0x100          ;302
000108  f1080801          ADD      r8,r8,#1              ;283
                  |L9.268|
00010c  17e9              ASRS     r1,r5,#31             ;283
00010e  eb056111          ADD      r1,r5,r1,LSR #24      ;283
000112  ebb82f21          CMP      r8,r1,ASR #8          ;283
000116  d3d4              BCC      |L9.194|
000118  2000              MOVS     r0,#0                 ;306
00011a  f7fffffe          BL       sf_SetCS
00011e  2004              MOVS     r0,#4                 ;307
000120  f7fffffe          BL       bsp_spiWrite1
000124  2001              MOVS     r0,#1                 ;308
000126  f7fffffe          BL       sf_SetCS
00012a  f7fffffe          BL       sf_WaitForWriteEnd
                  |L9.302|
00012e  bf00              NOP      
000130  e779              B        |L9.38|
;;;313    
                          ENDP

000132  0000              DCW      0x0000
                  |L9.308|
                          DCD      g_tSF
                  |L9.312|
                          DCD      0x00bf2541

                          AREA ||i.sf_ReadBuffer||, CODE, READONLY, ALIGN=2

                  sf_ReadBuffer PROC
;;;323    */
;;;324    void sf_ReadBuffer(uint8_t * _pBuf, uint32_t _uiReadAddr, uint32_t _uiSize)
000000  b570              PUSH     {r4-r6,lr}
;;;325    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;326    	/* 如果读取的数据长度为0或者超出串行Flash地址空间，则直接返回 */
;;;327    	if ((_uiSize == 0) ||(_uiReadAddr + _uiSize) > g_tSF.TotalSize)
000008  b125              CBZ      r5,|L10.20|
00000a  1960              ADDS     r0,r4,r5
00000c  4911              LDR      r1,|L10.84|
00000e  6949              LDR      r1,[r1,#0x14]  ; g_tSF
000010  4288              CMP      r0,r1
000012  d900              BLS      |L10.22|
                  |L10.20|
;;;328    	{
;;;329    		return;
;;;330    	}
;;;331    
;;;332    	/* 擦除扇区操作 */
;;;333    	sf_SetCS(0);									/* 使能片选 */
;;;334    	bsp_spiWrite1(CMD_READ);							/* 发送读命令 */
;;;335    	bsp_spiWrite1((_uiReadAddr & 0xFF0000) >> 16);	/* 发送扇区地址的高8bit */
;;;336    	bsp_spiWrite1((_uiReadAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
;;;337    	bsp_spiWrite1(_uiReadAddr & 0xFF);				/* 发送扇区地址低8bit */
;;;338    	while (_uiSize--)
;;;339    	{
;;;340    		*_pBuf++ = bsp_spiRead1();			/* 读一个字节并存储到pBuf，读完后指针自加1 */
;;;341    	}
;;;342    	sf_SetCS(1);									/* 禁能片选 */
;;;343    }
000014  bd70              POP      {r4-r6,pc}
                  |L10.22|
000016  2000              MOVS     r0,#0                 ;333
000018  f7fffffe          BL       sf_SetCS
00001c  2003              MOVS     r0,#3                 ;334
00001e  f7fffffe          BL       bsp_spiWrite1
000022  f3c44007          UBFX     r0,r4,#16,#8          ;335
000026  f7fffffe          BL       bsp_spiWrite1
00002a  f3c42007          UBFX     r0,r4,#8,#8           ;336
00002e  f7fffffe          BL       bsp_spiWrite1
000032  b2e0              UXTB     r0,r4                 ;337
000034  f7fffffe          BL       bsp_spiWrite1
000038  e003              B        |L10.66|
                  |L10.58|
00003a  f7fffffe          BL       bsp_spiRead1
00003e  f8060b01          STRB     r0,[r6],#1            ;340
                  |L10.66|
000042  0028              MOVS     r0,r5                 ;338
000044  f1a50501          SUB      r5,r5,#1              ;338
000048  d1f7              BNE      |L10.58|
00004a  2001              MOVS     r0,#1                 ;342
00004c  f7fffffe          BL       sf_SetCS
000050  bf00              NOP      
000052  e7df              B        |L10.20|
;;;344    
                          ENDP

                  |L10.84|
                          DCD      g_tSF

                          AREA ||i.sf_ReadID||, CODE, READONLY, ALIGN=1

                  sf_ReadID PROC
;;;656    */
;;;657    uint32_t sf_ReadID(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;658    {
;;;659    	uint32_t uiID;
;;;660    	uint8_t id1, id2, id3;
;;;661    
;;;662    	sf_SetCS(0);									/* 使能片选 */
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       sf_SetCS
;;;663    	bsp_spiWrite1(CMD_RDID);								/* 发送读ID命令 */
00000a  209f              MOVS     r0,#0x9f
00000c  f7fffffe          BL       bsp_spiWrite1
;;;664    	id1 = bsp_spiRead1();					/* 读ID的第1个字节 */
000010  f7fffffe          BL       bsp_spiRead1
000014  4605              MOV      r5,r0
;;;665    	id2 = bsp_spiRead1();					/* 读ID的第2个字节 */
000016  f7fffffe          BL       bsp_spiRead1
00001a  4606              MOV      r6,r0
;;;666    	id3 = bsp_spiRead1();					/* 读ID的第3个字节 */
00001c  f7fffffe          BL       bsp_spiRead1
000020  4607              MOV      r7,r0
;;;667    	sf_SetCS(1);									/* 禁能片选 */
000022  2001              MOVS     r0,#1
000024  f7fffffe          BL       sf_SetCS
;;;668    
;;;669    	uiID = ((uint32_t)id1 << 16) | ((uint32_t)id2 << 8) | id3;
000028  0428              LSLS     r0,r5,#16
00002a  ea402006          ORR      r0,r0,r6,LSL #8
00002e  ea400407          ORR      r4,r0,r7
;;;670    
;;;671    	return uiID;
000032  4620              MOV      r0,r4
;;;672    }
000034  e8bd81f0          POP      {r4-r8,pc}
;;;673    
                          ENDP


                          AREA ||i.sf_ReadInfo||, CODE, READONLY, ALIGN=2

                  sf_ReadInfo PROC
;;;681    */
;;;682    void sf_ReadInfo(void)
000000  b510              PUSH     {r4,lr}
;;;683    {
;;;684    	/* 自动识别串行Flash型号 */
;;;685    	{
;;;686    		g_tSF.ChipID = sf_ReadID();	/* 芯片ID */
000002  f7fffffe          BL       sf_ReadID
000006  4927              LDR      r1,|L12.164|
000008  6008              STR      r0,[r1,#0]  ; g_tSF
;;;687    
;;;688    		switch (g_tSF.ChipID)
00000a  4608              MOV      r0,r1
00000c  6800              LDR      r0,[r0,#0]  ; g_tSF
00000e  4926              LDR      r1,|L12.168|
000010  1840              ADDS     r0,r0,r1
000012  d008              BEQ      |L12.38|
000014  4925              LDR      r1,|L12.172|
000016  1840              ADDS     r0,r0,r1
000018  d011              BEQ      |L12.62|
00001a  4925              LDR      r1,|L12.176|
00001c  1840              ADDS     r0,r0,r1
00001e  d01a              BEQ      |L12.86|
000020  2801              CMP      r0,#1
000022  d130              BNE      |L12.134|
000024  e023              B        |L12.110|
                  |L12.38|
;;;689    		{
;;;690    			case SST25VF016B_ID:
;;;691    				strcpy(g_tSF.ChipName, "SST25VF016B");
000026  a123              ADR      r1,|L12.180|
000028  481e              LDR      r0,|L12.164|
00002a  1d00              ADDS     r0,r0,#4
00002c  f7fffffe          BL       strcpy
;;;692    				g_tSF.TotalSize = 2 * 1024 * 1024;	/* 总容量 = 2M */
000030  f44f1000          MOV      r0,#0x200000
000034  491b              LDR      r1,|L12.164|
000036  6148              STR      r0,[r1,#0x14]  ; g_tSF
;;;693    				g_tSF.PageSize = 4 * 1024;			/* 页面大小 = 4K */
000038  1240              ASRS     r0,r0,#9
00003a  8308              STRH     r0,[r1,#0x18]
;;;694    				break;
00003c  e02f              B        |L12.158|
                  |L12.62|
;;;695    
;;;696    			case MX25L1606E_ID:
;;;697    				strcpy(g_tSF.ChipName, "MX25L1606E");
00003e  a120              ADR      r1,|L12.192|
000040  4818              LDR      r0,|L12.164|
000042  1d00              ADDS     r0,r0,#4
000044  f7fffffe          BL       strcpy
;;;698    				g_tSF.TotalSize = 2 * 1024 * 1024;	/* 总容量 = 2M */
000048  f44f1000          MOV      r0,#0x200000
00004c  4915              LDR      r1,|L12.164|
00004e  6148              STR      r0,[r1,#0x14]  ; g_tSF
;;;699    				g_tSF.PageSize = 4 * 1024;			/* 页面大小 = 4K */
000050  1240              ASRS     r0,r0,#9
000052  8308              STRH     r0,[r1,#0x18]
;;;700    				break;
000054  e023              B        |L12.158|
                  |L12.86|
;;;701    
;;;702    			case W25Q64_ID:
;;;703    				strcpy(g_tSF.ChipName, "W25Q64");
000056  a11d              ADR      r1,|L12.204|
000058  4812              LDR      r0,|L12.164|
00005a  1d00              ADDS     r0,r0,#4
00005c  f7fffffe          BL       strcpy
;;;704    				g_tSF.TotalSize = 8 * 1024 * 1024;	/* 总容量 = 8M */
000060  f44f0000          MOV      r0,#0x800000
000064  490f              LDR      r1,|L12.164|
000066  6148              STR      r0,[r1,#0x14]  ; g_tSF
;;;705    				g_tSF.PageSize = 4 * 1024;			/* 页面大小 = 4K */
000068  12c0              ASRS     r0,r0,#11
00006a  8308              STRH     r0,[r1,#0x18]
;;;706    				break;
00006c  e017              B        |L12.158|
                  |L12.110|
;;;707    
;;;708    
;;;709    			case W25Q128_ID:
;;;710    				strcpy(g_tSF.ChipName, "W25Q128");
00006e  a119              ADR      r1,|L12.212|
000070  480c              LDR      r0,|L12.164|
000072  1d00              ADDS     r0,r0,#4
000074  f7fffffe          BL       strcpy
;;;711    				g_tSF.TotalSize = 16 * 1024 * 1024;	/* 总容量 = 16M */
000078  f04f7080          MOV      r0,#0x1000000
00007c  4909              LDR      r1,|L12.164|
00007e  6148              STR      r0,[r1,#0x14]  ; g_tSF
;;;712    				g_tSF.PageSize = 4 * 1024;			/* 页面大小 = 4K */
000080  1300              ASRS     r0,r0,#12
000082  8308              STRH     r0,[r1,#0x18]
;;;713    				break;			
000084  e00b              B        |L12.158|
                  |L12.134|
;;;714    
;;;715    			default:
;;;716    				strcpy(g_tSF.ChipName, "Unknow Flash");
000086  a115              ADR      r1,|L12.220|
000088  4806              LDR      r0,|L12.164|
00008a  1d00              ADDS     r0,r0,#4
00008c  f7fffffe          BL       strcpy
;;;717    				g_tSF.TotalSize = 2 * 1024 * 1024;//2M字节
000090  f44f1000          MOV      r0,#0x200000
000094  4903              LDR      r1,|L12.164|
000096  6148              STR      r0,[r1,#0x14]  ; g_tSF
;;;718    				g_tSF.PageSize = 4 * 1024;
000098  1240              ASRS     r0,r0,#9
00009a  8308              STRH     r0,[r1,#0x18]
;;;719    				break;
00009c  bf00              NOP      
                  |L12.158|
00009e  bf00              NOP                            ;694
;;;720    		}
;;;721    	}
;;;722    }
0000a0  bd10              POP      {r4,pc}
;;;723    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L12.164|
                          DCD      g_tSF
                  |L12.168|
                          DCD      0xff40dabf
                  |L12.172|
                          DCD      0xfffd052c
                  |L12.176|
                          DCD      0xffd2dffe
                  |L12.180|
0000b4  53535432          DCB      "SST25VF016B",0
0000b8  35564630
0000bc  31364200
                  |L12.192|
0000c0  4d583235          DCB      "MX25L1606E",0
0000c4  4c313630
0000c8  364500  
0000cb  00                DCB      0
                  |L12.204|
0000cc  57323551          DCB      "W25Q64",0
0000d0  363400  
0000d3  00                DCB      0
                  |L12.212|
0000d4  57323551          DCB      "W25Q128",0
0000d8  31323800
                  |L12.220|
0000dc  556e6b6e          DCB      "Unknow Flash",0
0000e0  6f772046
0000e4  6c617368
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0

                          AREA ||i.sf_SetCS||, CODE, READONLY, ALIGN=2

                  sf_SetCS PROC
;;;131    */
;;;132    static void sf_SetCS(uint8_t _level)
000000  b510              PUSH     {r4,lr}
;;;133    {
000002  4604              MOV      r4,r0
;;;134    	if (_level == 0)
000004  b94c              CBNZ     r4,|L13.26|
;;;135    	{
;;;136    		bsp_SpiBusEnter();	/* 占用SPI总线， 用于总线共享 */
000006  f7fffffe          BL       bsp_SpiBusEnter
;;;137    
;;;138    		#ifdef SOFT_SPI		/* 软件SPI */
;;;139    			bsp_SetSpiSck(1);
;;;140    			SF_CS_0();
;;;141    		#endif
;;;142    
;;;143    		#ifdef HARD_SPI		/* 硬件SPI */
;;;144    
;;;145    			bsp_SPI_Init(SPI_Direction_2Lines_FullDuplex | SPI_Mode_Master | SPI_DataSize_8b
00000a  f2403017          MOV      r0,#0x317
00000e  f7fffffe          BL       bsp_SPI_Init
;;;146    				| SPI_CPOL_High | SPI_CPHA_2Edge | SPI_NSS_Soft | SPI_BaudRatePrescaler_8 | SPI_FirstBit_MSB);
;;;147    
;;;148    			SF_CS_0();
000012  2010              MOVS     r0,#0x10
000014  4904              LDR      r1,|L13.40|
000016  6148              STR      r0,[r1,#0x14]
000018  e004              B        |L13.36|
                  |L13.26|
;;;149    		#endif
;;;150    	}
;;;151    	else
;;;152    	{
;;;153    		SF_CS_1();
00001a  2010              MOVS     r0,#0x10
00001c  4902              LDR      r1,|L13.40|
00001e  6108              STR      r0,[r1,#0x10]
;;;154    
;;;155    		bsp_SpiBusExit();	/* 释放SPI总线， 用于总线共享 */
000020  f7fffffe          BL       bsp_SpiBusExit
                  |L13.36|
;;;156    	}
;;;157    }
000024  bd10              POP      {r4,pc}
;;;158    
                          ENDP

000026  0000              DCW      0x0000
                  |L13.40|
                          DCD      0x40011000

                          AREA ||i.sf_WaitForWriteEnd||, CODE, READONLY, ALIGN=1

                  sf_WaitForWriteEnd PROC
;;;779    */
;;;780    static void sf_WaitForWriteEnd(void)
000000  b510              PUSH     {r4,lr}
;;;781    {
;;;782    	sf_SetCS(0);									/* 使能片选 */
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       sf_SetCS
;;;783    	bsp_spiWrite1(CMD_RDSR);							/* 发送命令， 读状态寄存器 */
000008  2005              MOVS     r0,#5
00000a  f7fffffe          BL       bsp_spiWrite1
;;;784    	while((bsp_spiRead1() & WIP_FLAG) == SET);	/* 判断状态寄存器的忙标志位 */
00000e  bf00              NOP      
                  |L14.16|
000010  f7fffffe          BL       bsp_spiRead1
000014  f0100f01          TST      r0,#1
000018  d1fa              BNE      |L14.16|
;;;785    	sf_SetCS(1);									/* 禁能片选 */
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       sf_SetCS
;;;786    }
000020  bd10              POP      {r4,pc}
;;;787    
                          ENDP


                          AREA ||i.sf_WriteBuffer||, CODE, READONLY, ALIGN=2

                  sf_WriteBuffer PROC
;;;548    */
;;;549    uint8_t sf_WriteBuffer(uint8_t* _pBuf, uint32_t _uiWriteAddr, uint16_t _usWriteSize)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;550    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;551    	uint16_t NumOfPage = 0, NumOfSingle = 0, Addr = 0, count = 0, temp = 0;
00000a  f04f0800          MOV      r8,#0
00000e  46c1              MOV      r9,r8
000010  46c2              MOV      r10,r8
000012  2400              MOVS     r4,#0
000014  46a3              MOV      r11,r4
;;;552    
;;;553    	Addr = _uiWriteAddr % g_tSF.PageSize;
000016  4856              LDR      r0,|L15.368|
000018  8b00              LDRH     r0,[r0,#0x18]  ; g_tSF
00001a  fbb5f1f0          UDIV     r1,r5,r0
00001e  fb005011          MLS      r0,r0,r1,r5
000022  fa1ffa80          UXTH     r10,r0
;;;554    	count = g_tSF.PageSize - Addr;
000026  4852              LDR      r0,|L15.368|
000028  8b00              LDRH     r0,[r0,#0x18]  ; g_tSF
00002a  eba0000a          SUB      r0,r0,r10
00002e  b284              UXTH     r4,r0
;;;555    	NumOfPage =  _usWriteSize / g_tSF.PageSize;
000030  484f              LDR      r0,|L15.368|
000032  8b00              LDRH     r0,[r0,#0x18]  ; g_tSF
000034  fb96f0f0          SDIV     r0,r6,r0
000038  fa1ff880          UXTH     r8,r0
;;;556    	NumOfSingle = _usWriteSize % g_tSF.PageSize;
00003c  484c              LDR      r0,|L15.368|
00003e  8b00              LDRH     r0,[r0,#0x18]  ; g_tSF
000040  fb96f1f0          SDIV     r1,r6,r0
000044  fb006011          MLS      r0,r0,r1,r6
000048  fa1ff980          UXTH     r9,r0
;;;557    
;;;558    	if (Addr == 0) /* 起始地址是页面首地址  */
00004c  f1ba0f00          CMP      r10,#0
000050  d12a              BNE      |L15.168|
;;;559    	{
;;;560    		if (NumOfPage == 0) /* 数据长度小于页面大小 */
000052  f1b80f00          CMP      r8,#0
000056  d108              BNE      |L15.106|
;;;561    		{
;;;562    			if (sf_AutoWritePage(_pBuf, _uiWriteAddr, _usWriteSize) == 0)
000058  4632              MOV      r2,r6
00005a  4629              MOV      r1,r5
00005c  4638              MOV      r0,r7
00005e  f7fffffe          BL       sf_AutoWritePage
000062  2800              CMP      r0,#0
000064  d17e              BNE      |L15.356|
                  |L15.102|
;;;563    			{
;;;564    				return 0;
;;;565    			}
;;;566    		}
;;;567    		else 	/* 数据长度大于等于页面大小 */
;;;568    		{
;;;569    			while (NumOfPage--)
;;;570    			{
;;;571    				if (sf_AutoWritePage(_pBuf, _uiWriteAddr, g_tSF.PageSize) == 0)
;;;572    				{
;;;573    					return 0;
;;;574    				}
;;;575    				_uiWriteAddr +=  g_tSF.PageSize;
;;;576    				_pBuf += g_tSF.PageSize;
;;;577    			}
;;;578    			if (sf_AutoWritePage(_pBuf, _uiWriteAddr, NumOfSingle) == 0)
;;;579    			{
;;;580    				return 0;
;;;581    			}
;;;582    		}
;;;583    	}
;;;584    	else  /* 起始地址不是页面首地址  */
;;;585    	{
;;;586    		if (NumOfPage == 0) /* 数据长度小于页面大小 */
;;;587    		{
;;;588    			if (NumOfSingle > count) /* (_usWriteSize + _uiWriteAddr) > SPI_FLASH_PAGESIZE */
;;;589    			{
;;;590    				temp = NumOfSingle - count;
;;;591    
;;;592    				if (sf_AutoWritePage(_pBuf, _uiWriteAddr, count) == 0)
;;;593    				{
;;;594    					return 0;
;;;595    				}
;;;596    
;;;597    				_uiWriteAddr +=  count;
;;;598    				_pBuf += count;
;;;599    
;;;600    				if (sf_AutoWritePage(_pBuf, _uiWriteAddr, temp) == 0)
;;;601    				{
;;;602    					return 0;
;;;603    				}
;;;604    			}
;;;605    			else
;;;606    			{
;;;607    				if (sf_AutoWritePage(_pBuf, _uiWriteAddr, _usWriteSize) == 0)
;;;608    				{
;;;609    					return 0;
;;;610    				}
;;;611    			}
;;;612    		}
;;;613    		else	/* 数据长度大于等于页面大小 */
;;;614    		{
;;;615    			_usWriteSize -= count;
;;;616    			NumOfPage =  _usWriteSize / g_tSF.PageSize;
;;;617    			NumOfSingle = _usWriteSize % g_tSF.PageSize;
;;;618    
;;;619    			if (sf_AutoWritePage(_pBuf, _uiWriteAddr, count) == 0)
;;;620    			{
;;;621    				return 0;
;;;622    			}
;;;623    
;;;624    			_uiWriteAddr +=  count;
;;;625    			_pBuf += count;
;;;626    
;;;627    			while (NumOfPage--)
;;;628    			{
;;;629    				if (sf_AutoWritePage(_pBuf, _uiWriteAddr, g_tSF.PageSize) == 0)
;;;630    				{
;;;631    					return 0;
;;;632    				}
;;;633    				_uiWriteAddr +=  g_tSF.PageSize;
;;;634    				_pBuf += g_tSF.PageSize;
;;;635    			}
;;;636    
;;;637    			if (NumOfSingle != 0)
;;;638    			{
;;;639    				if (sf_AutoWritePage(_pBuf, _uiWriteAddr, NumOfSingle) == 0)
;;;640    				{
;;;641    					return 0;
;;;642    				}
;;;643    			}
;;;644    		}
;;;645    	}
;;;646    	return 1;	/* 成功 */
;;;647    }
000066  e8bd9ff0          POP      {r4-r12,pc}
                  |L15.106|
00006a  e00e              B        |L15.138|
                  |L15.108|
00006c  4840              LDR      r0,|L15.368|
00006e  8b02              LDRH     r2,[r0,#0x18]         ;571  ; g_tSF
000070  4629              MOV      r1,r5                 ;571
000072  4638              MOV      r0,r7                 ;571
000074  f7fffffe          BL       sf_AutoWritePage
000078  b908              CBNZ     r0,|L15.126|
00007a  2000              MOVS     r0,#0                 ;573
00007c  e7f3              B        |L15.102|
                  |L15.126|
00007e  483c              LDR      r0,|L15.368|
000080  8b00              LDRH     r0,[r0,#0x18]         ;575  ; g_tSF
000082  4405              ADD      r5,r5,r0              ;575
000084  483a              LDR      r0,|L15.368|
000086  8b00              LDRH     r0,[r0,#0x18]         ;576  ; g_tSF
000088  4407              ADD      r7,r7,r0              ;576
                  |L15.138|
00008a  ea5f0008          MOVS     r0,r8                 ;569
00008e  f1a80101          SUB      r1,r8,#1              ;569
000092  fa1ff881          UXTH     r8,r1                 ;569
000096  d1e9              BNE      |L15.108|
000098  464a              MOV      r2,r9                 ;578
00009a  4629              MOV      r1,r5                 ;578
00009c  4638              MOV      r0,r7                 ;578
00009e  f7fffffe          BL       sf_AutoWritePage
0000a2  2800              CMP      r0,#0                 ;578
0000a4  d161              BNE      |L15.362|
0000a6  e7de              B        |L15.102|
                  |L15.168|
0000a8  f1b80f00          CMP      r8,#0                 ;586
0000ac  d11f              BNE      |L15.238|
0000ae  45a1              CMP      r9,r4                 ;588
0000b0  dd15              BLE      |L15.222|
0000b2  eba90004          SUB      r0,r9,r4              ;590
0000b6  fa1ffb80          UXTH     r11,r0                ;590
0000ba  4622              MOV      r2,r4                 ;592
0000bc  4629              MOV      r1,r5                 ;592
0000be  4638              MOV      r0,r7                 ;592
0000c0  f7fffffe          BL       sf_AutoWritePage
0000c4  b908              CBNZ     r0,|L15.202|
0000c6  2000              MOVS     r0,#0                 ;594
0000c8  e7cd              B        |L15.102|
                  |L15.202|
0000ca  4425              ADD      r5,r5,r4              ;597
0000cc  4427              ADD      r7,r7,r4              ;598
0000ce  465a              MOV      r2,r11                ;600
0000d0  4629              MOV      r1,r5                 ;600
0000d2  4638              MOV      r0,r7                 ;600
0000d4  f7fffffe          BL       sf_AutoWritePage
0000d8  2800              CMP      r0,#0                 ;600
0000da  d146              BNE      |L15.362|
0000dc  e7c3              B        |L15.102|
                  |L15.222|
0000de  4632              MOV      r2,r6                 ;607
0000e0  4629              MOV      r1,r5                 ;607
0000e2  4638              MOV      r0,r7                 ;607
0000e4  f7fffffe          BL       sf_AutoWritePage
0000e8  bbe0              CBNZ     r0,|L15.356|
0000ea  2000              MOVS     r0,#0                 ;609
0000ec  e7bb              B        |L15.102|
                  |L15.238|
0000ee  1b30              SUBS     r0,r6,r4              ;615
0000f0  b286              UXTH     r6,r0                 ;615
0000f2  481f              LDR      r0,|L15.368|
0000f4  8b00              LDRH     r0,[r0,#0x18]         ;616  ; g_tSF
0000f6  fb96f0f0          SDIV     r0,r6,r0              ;616
0000fa  fa1ff880          UXTH     r8,r0                 ;616
0000fe  481c              LDR      r0,|L15.368|
000100  8b00              LDRH     r0,[r0,#0x18]         ;617  ; g_tSF
000102  fb96f1f0          SDIV     r1,r6,r0              ;617
000106  fb006011          MLS      r0,r0,r1,r6           ;617
00010a  fa1ff980          UXTH     r9,r0                 ;617
00010e  4622              MOV      r2,r4                 ;619
000110  4629              MOV      r1,r5                 ;619
000112  4638              MOV      r0,r7                 ;619
000114  f7fffffe          BL       sf_AutoWritePage
000118  b908              CBNZ     r0,|L15.286|
00011a  2000              MOVS     r0,#0                 ;621
00011c  e7a3              B        |L15.102|
                  |L15.286|
00011e  4425              ADD      r5,r5,r4              ;624
000120  4427              ADD      r7,r7,r4              ;625
000122  e00e              B        |L15.322|
                  |L15.292|
000124  4812              LDR      r0,|L15.368|
000126  8b02              LDRH     r2,[r0,#0x18]         ;629  ; g_tSF
000128  4629              MOV      r1,r5                 ;629
00012a  4638              MOV      r0,r7                 ;629
00012c  f7fffffe          BL       sf_AutoWritePage
000130  b908              CBNZ     r0,|L15.310|
000132  2000              MOVS     r0,#0                 ;631
000134  e797              B        |L15.102|
                  |L15.310|
000136  480e              LDR      r0,|L15.368|
000138  8b00              LDRH     r0,[r0,#0x18]         ;633  ; g_tSF
00013a  4405              ADD      r5,r5,r0              ;633
00013c  480c              LDR      r0,|L15.368|
00013e  8b00              LDRH     r0,[r0,#0x18]         ;634  ; g_tSF
000140  4407              ADD      r7,r7,r0              ;634
                  |L15.322|
000142  ea5f0008          MOVS     r0,r8                 ;627
000146  f1a80101          SUB      r1,r8,#1              ;627
00014a  fa1ff881          UXTH     r8,r1                 ;627
00014e  d1e9              BNE      |L15.292|
000150  f1b90f00          CMP      r9,#0                 ;637
000154  d009              BEQ      |L15.362|
000156  464a              MOV      r2,r9                 ;639
000158  4629              MOV      r1,r5                 ;639
00015a  4638              MOV      r0,r7                 ;639
00015c  f7fffffe          BL       sf_AutoWritePage
000160  b900              CBNZ     r0,|L15.356|
000162  e000              B        |L15.358|
                  |L15.356|
000164  e001              B        |L15.362|
                  |L15.358|
000166  2000              MOVS     r0,#0                 ;641
000168  e77d              B        |L15.102|
                  |L15.362|
00016a  2001              MOVS     r0,#1                 ;646
00016c  e77b              B        |L15.102|
;;;648    
                          ENDP

00016e  0000              DCW      0x0000
                  |L15.368|
                          DCD      g_tSF

                          AREA ||i.sf_WriteEnable||, CODE, READONLY, ALIGN=1

                  sf_WriteEnable PROC
;;;731    */
;;;732    static void sf_WriteEnable(void)
000000  b510              PUSH     {r4,lr}
;;;733    {
;;;734    	sf_SetCS(0);									/* 使能片选 */
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       sf_SetCS
;;;735    	bsp_spiWrite1(CMD_WREN);								/* 发送命令 */
000008  2006              MOVS     r0,#6
00000a  f7fffffe          BL       bsp_spiWrite1
;;;736    	sf_SetCS(1);									/* 禁能片选 */
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       sf_SetCS
;;;737    }
000014  bd10              POP      {r4,pc}
;;;738    
                          ENDP


                          AREA ||i.sf_WriteStatus||, CODE, READONLY, ALIGN=2

                  sf_WriteStatus PROC
;;;746    */
;;;747    static void sf_WriteStatus(uint8_t _ucValue)
000000  b510              PUSH     {r4,lr}
;;;748    {
000002  4604              MOV      r4,r0
;;;749    
;;;750    	if (g_tSF.ChipID == SST25VF016B_ID)
000004  4813              LDR      r0,|L17.84|
000006  6800              LDR      r0,[r0,#0]  ; g_tSF
000008  4913              LDR      r1,|L17.88|
00000a  4288              CMP      r0,r1
00000c  d115              BNE      |L17.58|
;;;751    	{
;;;752    		/* 第1步：先使能写状态寄存器 */
;;;753    		sf_SetCS(0);									/* 使能片选 */
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       sf_SetCS
;;;754    		bsp_spiWrite1(CMD_EWRSR);							/* 发送命令， 允许写状态寄存器 */
000014  2050              MOVS     r0,#0x50
000016  f7fffffe          BL       bsp_spiWrite1
;;;755    		sf_SetCS(1);									/* 禁能片选 */
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       sf_SetCS
;;;756    
;;;757    		/* 第2步：再写状态寄存器 */
;;;758    		sf_SetCS(0);									/* 使能片选 */
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       sf_SetCS
;;;759    		bsp_spiWrite1(CMD_WRSR);							/* 发送命令， 写状态寄存器 */
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       bsp_spiWrite1
;;;760    		bsp_spiWrite1(_ucValue);							/* 发送数据：状态寄存器的值 */
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       bsp_spiWrite1
;;;761    		sf_SetCS(1);									/* 禁能片选 */
000032  2001              MOVS     r0,#1
000034  f7fffffe          BL       sf_SetCS
000038  e00b              B        |L17.82|
                  |L17.58|
;;;762    	}
;;;763    	else
;;;764    	{
;;;765    		sf_SetCS(0);									/* 使能片选 */
00003a  2000              MOVS     r0,#0
00003c  f7fffffe          BL       sf_SetCS
;;;766    		bsp_spiWrite1(CMD_WRSR);							/* 发送命令， 写状态寄存器 */
000040  2001              MOVS     r0,#1
000042  f7fffffe          BL       bsp_spiWrite1
;;;767    		bsp_spiWrite1(_ucValue);							/* 发送数据：状态寄存器的值 */
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       bsp_spiWrite1
;;;768    		sf_SetCS(1);									/* 禁能片选 */
00004c  2001              MOVS     r0,#1
00004e  f7fffffe          BL       sf_SetCS
                  |L17.82|
;;;769    	}
;;;770    }
000052  bd10              POP      {r4,pc}
;;;771    
                          ENDP

                  |L17.84|
                          DCD      g_tSF
                  |L17.88|
                          DCD      0x00bf2541

                          AREA ||i.sf_exWrite8Bytes||, CODE, READONLY, ALIGN=1

                  sf_exWrite8Bytes PROC
;;;788    //在指定地址依次写入8字节数据
;;;789    void sf_exWrite8Bytes(uint8_t* _pBuf, uint32_t _uiWriteAddr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;790    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;791        uint16_t i;
;;;792        uint16_t _usWriteSize = 8;
000008  2708              MOVS     r7,#8
;;;793        
;;;794        sf_WriteEnable();								/* 发送写使能命令 */
00000a  f7fffffe          BL       sf_WriteEnable
;;;795    	sf_SetCS(0);									/* 使能片选 */
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       sf_SetCS
;;;796    	bsp_spiWrite1(0x02);								/* 页编程 */
000014  2002              MOVS     r0,#2
000016  f7fffffe          BL       bsp_spiWrite1
;;;797    	bsp_spiWrite1((_uiWriteAddr & 0xFF0000) >> 16);	/* 发送扇区地址的高8bit */
00001a  f3c44007          UBFX     r0,r4,#16,#8
00001e  f7fffffe          BL       bsp_spiWrite1
;;;798    	bsp_spiWrite1((_uiWriteAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
000022  f3c42007          UBFX     r0,r4,#8,#8
000026  f7fffffe          BL       bsp_spiWrite1
;;;799    	bsp_spiWrite1(_uiWriteAddr & 0xFF);				/* 发送扇区地址低8bit */
00002a  b2e0              UXTB     r0,r4
00002c  f7fffffe          BL       bsp_spiWrite1
;;;800    
;;;801    	for (i = 0; i < _usWriteSize; i++)
000030  2600              MOVS     r6,#0
000032  e005              B        |L18.64|
                  |L18.52|
;;;802    	{
;;;803    		bsp_spiWrite1(*_pBuf++);					/* 发送数据 */
000034  f8150b01          LDRB     r0,[r5],#1
000038  f7fffffe          BL       bsp_spiWrite1
00003c  1c70              ADDS     r0,r6,#1              ;801
00003e  b286              UXTH     r6,r0                 ;801
                  |L18.64|
000040  42be              CMP      r6,r7                 ;801
000042  dbf7              BLT      |L18.52|
;;;804    	}
;;;805    
;;;806    	sf_SetCS(1);								/* 禁止片选 */
000044  2001              MOVS     r0,#1
000046  f7fffffe          BL       sf_SetCS
;;;807    
;;;808    	sf_WaitForWriteEnd();						/* 等待串行Flash内部写操作完成 */
00004a  f7fffffe          BL       sf_WaitForWriteEnd
;;;809        
;;;810        /* 进入写保护状态 */
;;;811    	sf_SetCS(0);
00004e  2000              MOVS     r0,#0
000050  f7fffffe          BL       sf_SetCS
;;;812    	bsp_spiWrite1(CMD_DISWR);
000054  2004              MOVS     r0,#4
000056  f7fffffe          BL       bsp_spiWrite1
;;;813    	sf_SetCS(1);
00005a  2001              MOVS     r0,#1
00005c  f7fffffe          BL       sf_SetCS
;;;814    
;;;815    	sf_WaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */    
000060  f7fffffe          BL       sf_WaitForWriteEnd
;;;816    }
000064  e8bd81f0          POP      {r4-r8,pc}
;;;817    
                          ENDP


                          AREA ||i.sf_exWriteOnePage||, CODE, READONLY, ALIGN=1

                  sf_exWriteOnePage PROC
;;;818    //在指定地址依次写入256字节数据
;;;819    void sf_exWriteOnePage(uint8_t* _pBuf, uint32_t _uiWriteAddr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;820    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;821        uint16_t i;
;;;822        uint16_t _usWriteSize = 256;
000008  f44f7780          MOV      r7,#0x100
;;;823        sf_WriteEnable();								/* 发送写使能命令 */
00000c  f7fffffe          BL       sf_WriteEnable
;;;824    
;;;825    	sf_SetCS(0);									/* 使能片选 */
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       sf_SetCS
;;;826    	bsp_spiWrite1(0x02);								/* 页编程 */
000016  2002              MOVS     r0,#2
000018  f7fffffe          BL       bsp_spiWrite1
;;;827    	bsp_spiWrite1((_uiWriteAddr & 0xFF0000) >> 16);	/* 发送扇区地址的高8bit */
00001c  f3c44007          UBFX     r0,r4,#16,#8
000020  f7fffffe          BL       bsp_spiWrite1
;;;828    	bsp_spiWrite1((_uiWriteAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
000024  f3c42007          UBFX     r0,r4,#8,#8
000028  f7fffffe          BL       bsp_spiWrite1
;;;829    	bsp_spiWrite1(_uiWriteAddr & 0xFF);				/* 发送扇区地址低8bit */
00002c  b2e0              UXTB     r0,r4
00002e  f7fffffe          BL       bsp_spiWrite1
;;;830    
;;;831    	for (i = 0; i < _usWriteSize; i++)
000032  2600              MOVS     r6,#0
000034  e005              B        |L19.66|
                  |L19.54|
;;;832    	{
;;;833    		bsp_spiWrite1(*_pBuf++);					/* 发送数据 */
000036  f8150b01          LDRB     r0,[r5],#1
00003a  f7fffffe          BL       bsp_spiWrite1
00003e  1c70              ADDS     r0,r6,#1              ;831
000040  b286              UXTH     r6,r0                 ;831
                  |L19.66|
000042  42be              CMP      r6,r7                 ;831
000044  dbf7              BLT      |L19.54|
;;;834    	}
;;;835    
;;;836    	sf_SetCS(1);								/* 禁止片选 */
000046  2001              MOVS     r0,#1
000048  f7fffffe          BL       sf_SetCS
;;;837    
;;;838    	sf_WaitForWriteEnd();						/* 等待串行Flash内部写操作完成 */
00004c  f7fffffe          BL       sf_WaitForWriteEnd
;;;839    
;;;840    	_uiWriteAddr += 256;
000050  f5047480          ADD      r4,r4,#0x100
;;;841    
;;;842        /* 进入写保护状态 */
;;;843    	sf_SetCS(0);
000054  2000              MOVS     r0,#0
000056  f7fffffe          BL       sf_SetCS
;;;844    	bsp_spiWrite1(CMD_DISWR);
00005a  2004              MOVS     r0,#4
00005c  f7fffffe          BL       bsp_spiWrite1
;;;845    	sf_SetCS(1);
000060  2001              MOVS     r0,#1
000062  f7fffffe          BL       sf_SetCS
;;;846    
;;;847    	sf_WaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */
000066  f7fffffe          BL       sf_WaitForWriteEnd
;;;848    }
00006a  e8bd81f0          POP      {r4-r8,pc}
;;;849    
                          ENDP


                          AREA ||i.storeRecord||, CODE, READONLY, ALIGN=2

                  storeRecord PROC
;;;850    //写入刷卡记录
;;;851    void storeRecord(uint8_t *id, uint8_t reader)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;852    {
000004  4680              MOV      r8,r0
000006  460f              MOV      r7,r1
;;;853        uint8_t record[8];
;;;854        uint16_t sector = (g_tParam.nextStartAddr.nextStartSector[0]<<8) + g_tParam.nextStartAddr.nextStartSector[1];
000008  482e              LDR      r0,|L20.196|
00000a  f8900033          LDRB     r0,[r0,#0x33]
00000e  492d              LDR      r1,|L20.196|
000010  f8911032          LDRB     r1,[r1,#0x32]  ; g_tParam
000014  eb002001          ADD      r0,r0,r1,LSL #8
000018  b284              UXTH     r4,r0
;;;855        uint16_t addr = (g_tParam.nextStartAddr.nextStartAddr[0]<<8) + g_tParam.nextStartAddr.nextStartAddr[1];
00001a  482a              LDR      r0,|L20.196|
00001c  f8900035          LDRB     r0,[r0,#0x35]
000020  4928              LDR      r1,|L20.196|
000022  f8911034          LDRB     r1,[r1,#0x34]  ; g_tParam
000026  eb002001          ADD      r0,r0,r1,LSL #8
00002a  b285              UXTH     r5,r0
;;;856        uint32_t _uiWriteAddr = sector*g_tSF.PageSize + addr;
00002c  4826              LDR      r0,|L20.200|
00002e  8b00              LDRH     r0,[r0,#0x18]  ; g_tSF
000030  fb045600          MLA      r6,r4,r0,r5
;;;857        
;;;858        if(addr == 0)
000034  b92d              CBNZ     r5,|L20.66|
;;;859        {
;;;860            sf_EraseSector(sector*g_tSF.PageSize);
000036  4924              LDR      r1,|L20.200|
000038  8b09              LDRH     r1,[r1,#0x18]  ; g_tSF
00003a  fb01f004          MUL      r0,r1,r4
00003e  f7fffffe          BL       sf_EraseSector
                  |L20.66|
;;;861        }
;;;862        
;;;863        memcpy(&record[0], id, 3);
000042  f8b80000          LDRH     r0,[r8,#0]
000046  f8ad0000          STRH     r0,[sp,#0]
00004a  f8980002          LDRB     r0,[r8,#2]
00004e  f88d0002          STRB     r0,[sp,#2]
;;;864        
;;;865        memcpy(&record[3], g_tRunInfo.time, sizeof(g_tRunInfo.time));
000052  481e              LDR      r0,|L20.204|
000054  f8d01006          LDR      r1,[r0,#6]  ; g_tRunInfo
000058  f8cd1003          STR      r1,[sp,#3]
00005c  7a80              LDRB     r0,[r0,#0xa]  ; g_tRunInfo
00005e  f88d0007          STRB     r0,[sp,#7]
;;;866        
;;;867        //月份1-12，则id[1]的高4位用来表示读头，0--A，1--B
;;;868        if(reader == e_READER_A)
000062  b927              CBNZ     r7,|L20.110|
;;;869        {
;;;870            record[4] += 0;
000064  f89d0004          LDRB     r0,[sp,#4]
000068  f88d0004          STRB     r0,[sp,#4]
00006c  e007              B        |L20.126|
                  |L20.110|
;;;871        }
;;;872        else if(reader == e_READER_B)
00006e  2f01              CMP      r7,#1
000070  d105              BNE      |L20.126|
;;;873        {
;;;874            record[4] += 1<<4;
000072  f89d0004          LDRB     r0,[sp,#4]
000076  3010              ADDS     r0,r0,#0x10
000078  b2c0              UXTB     r0,r0
00007a  f88d0004          STRB     r0,[sp,#4]
                  |L20.126|
;;;875        }
;;;876        
;;;877        sf_exWrite8Bytes(record, _uiWriteAddr);
00007e  4631              MOV      r1,r6
000080  4668              MOV      r0,sp
000082  f7fffffe          BL       sf_exWrite8Bytes
;;;878        
;;;879        _uiWriteAddr += 8;
000086  3608              ADDS     r6,r6,#8
;;;880        sector = _uiWriteAddr/g_tSF.PageSize;
000088  480f              LDR      r0,|L20.200|
00008a  8b00              LDRH     r0,[r0,#0x18]  ; g_tSF
00008c  fbb6f0f0          UDIV     r0,r6,r0
000090  b284              UXTH     r4,r0
;;;881        addr = _uiWriteAddr%g_tSF.PageSize;
000092  480d              LDR      r0,|L20.200|
000094  8b00              LDRH     r0,[r0,#0x18]  ; g_tSF
000096  fbb6f1f0          UDIV     r1,r6,r0
00009a  fb006011          MLS      r0,r0,r1,r6
00009e  b285              UXTH     r5,r0
;;;882        
;;;883        g_tParam.nextStartAddr.nextStartSector[0] = sector>>8;
0000a0  1220              ASRS     r0,r4,#8
0000a2  4908              LDR      r1,|L20.196|
0000a4  f8810032          STRB     r0,[r1,#0x32]
;;;884        g_tParam.nextStartAddr.nextStartSector[1] = sector&0xFF;
0000a8  4608              MOV      r0,r1
0000aa  f8804033          STRB     r4,[r0,#0x33]
;;;885        
;;;886        g_tParam.nextStartAddr.nextStartAddr[0] = addr>>8;
0000ae  1229              ASRS     r1,r5,#8
0000b0  f8801034          STRB     r1,[r0,#0x34]
;;;887        g_tParam.nextStartAddr.nextStartAddr[1] = addr&0xFF;
0000b4  f8805035          STRB     r5,[r0,#0x35]
;;;888        
;;;889        g_tParam.updateNextStartAddr(&g_tParam.nextStartAddr);
0000b8  68c1              LDR      r1,[r0,#0xc]  ; g_tParam
0000ba  3032              ADDS     r0,r0,#0x32
0000bc  4788              BLX      r1
;;;890    }
0000be  e8bd81fc          POP      {r2-r8,pc}
;;;891    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L20.196|
                          DCD      g_tParam
                  |L20.200|
                          DCD      g_tSF
                  |L20.204|
                          DCD      g_tRunInfo

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_tSF
                          %        28

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\SPI\\bsp_spi_flash.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_bsp_spi_flash_c_69e7dfca____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_bsp_spi_flash_c_69e7dfca____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_bsp_spi_flash_c_69e7dfca____REVSH|
#line 128
|__asm___15_bsp_spi_flash_c_69e7dfca____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
