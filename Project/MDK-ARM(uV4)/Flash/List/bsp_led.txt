; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_led.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_led.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\RTX\inc -I..\..\RTX\portable -I..\..\User\CpuFlash -I..\..\User\CRC8_16 -I..\..\User\DS1302 -I..\..\User\DWT -I..\..\User\IIC -I..\..\User\IWDG -I..\..\User\Key -I..\..\User\Led -I..\..\User\Net -I..\..\User\Protocal -I..\..\User\Reader -I..\..\User\SPI -I..\..\User\Timer -I..\..\User\Uart -I..\..\User\Param -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_led.crf ..\..\User\Led\bsp_led.c]
                          THUMB

                          AREA ||i.alarmOff||, CODE, READONLY, ALIGN=2

                  alarmOff PROC
;;;359    //关闭报警
;;;360    void alarmOff(enum ReaderOrButton_Enum type)
000000  b510              PUSH     {r4,lr}
;;;361    {
000002  4604              MOV      r4,r0
;;;362        switch(type)
000004  b114              CBZ      r4,|L1.12|
000006  2c01              CMP      r4,#1
000008  d10a              BNE      |L1.32|
00000a  e004              B        |L1.22|
                  |L1.12|
;;;363        {
;;;364            case e_READER_A:
;;;365                //GPIO_ResetBits(GPIO_PORT_ALARM, GPIO_PIN_ALARM_LED1);//置低电平
;;;366                GPIO_ResetBits(GPIO_PORT_ALARM, GPIO_PIN_ALARM_BEEP1);
00000c  2102              MOVS     r1,#2
00000e  4806              LDR      r0,|L1.40|
000010  f7fffffe          BL       GPIO_ResetBits
;;;367                break;
000014  e005              B        |L1.34|
                  |L1.22|
;;;368            
;;;369            case e_READER_B:
;;;370                //GPIO_ResetBits(GPIO_PORT_ALARM, GPIO_PIN_ALARM_LED2);//置低电平
;;;371                GPIO_ResetBits(GPIO_PORT_ALARM, GPIO_PIN_ALARM_BEEP2);
000016  2108              MOVS     r1,#8
000018  4803              LDR      r0,|L1.40|
00001a  f7fffffe          BL       GPIO_ResetBits
;;;372                break;
00001e  e000              B        |L1.34|
                  |L1.32|
;;;373                    
;;;374            default:
;;;375                break;
000020  bf00              NOP      
                  |L1.34|
000022  bf00              NOP                            ;367
;;;376        }
;;;377    }
000024  bd10              POP      {r4,pc}
;;;378    
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      0x40011000

                          AREA ||i.alarmOn||, CODE, READONLY, ALIGN=2

                  alarmOn PROC
;;;379    //打开报警
;;;380    void alarmOn(enum ReaderOrButton_Enum type)
000000  b510              PUSH     {r4,lr}
;;;381    {
000002  4604              MOV      r4,r0
;;;382        switch(type)
000004  b114              CBZ      r4,|L2.12|
000006  2c01              CMP      r4,#1
000008  d10a              BNE      |L2.32|
00000a  e004              B        |L2.22|
                  |L2.12|
;;;383        {
;;;384            case e_READER_A:
;;;385                //GPIO_SetBits(GPIO_PORT_ALARM, GPIO_PIN_ALARM_LED1);//置高电平
;;;386                GPIO_SetBits(GPIO_PORT_ALARM, GPIO_PIN_ALARM_BEEP1);
00000c  2102              MOVS     r1,#2
00000e  4806              LDR      r0,|L2.40|
000010  f7fffffe          BL       GPIO_SetBits
;;;387                break;
000014  e005              B        |L2.34|
                  |L2.22|
;;;388            
;;;389            case e_READER_B:
;;;390                //GPIO_SetBits(GPIO_PORT_ALARM, GPIO_PIN_ALARM_LED2);//置高电平
;;;391                GPIO_SetBits(GPIO_PORT_ALARM, GPIO_PIN_ALARM_BEEP2);
000016  2108              MOVS     r1,#8
000018  4803              LDR      r0,|L2.40|
00001a  f7fffffe          BL       GPIO_SetBits
;;;392                break;
00001e  e000              B        |L2.34|
                  |L2.32|
;;;393                    
;;;394            default:
;;;395                break;
000020  bf00              NOP      
                  |L2.34|
000022  bf00              NOP                            ;387
;;;396        }
;;;397    }
000024  bd10              POP      {r4,pc}
;;;398    
                          ENDP

000026  0000              DCW      0x0000
                  |L2.40|
                          DCD      0x40011000

                          AREA ||i.bsp_InitLed||, CODE, READONLY, ALIGN=2

                  bsp_InitLed PROC
;;;66     */
;;;67     void bsp_InitLed(void)
000000  b508              PUSH     {r3,lr}
;;;68     {
;;;69     	GPIO_InitTypeDef GPIO_InitStructure;
;;;70         //复制对应的函数指针
;;;71         g_tDoorStatus.openDoor = openDoor;
000002  482c              LDR      r0,|L3.180|
000004  492c              LDR      r1,|L3.184|
000006  6088              STR      r0,[r1,#8]  ; g_tDoorStatus
;;;72         g_tDoorStatus.closeDoor = closeDoor;
000008  482c              LDR      r0,|L3.188|
00000a  60c8              STR      r0,[r1,#0xc]  ; g_tDoorStatus
;;;73         g_tDoorStatus.readFeedBack = readFeedBack;
00000c  482c              LDR      r0,|L3.192|
00000e  6048              STR      r0,[r1,#4]  ; g_tDoorStatus
;;;74     	/* 打开GPIO时钟 */
;;;75     	RCC_APB2PeriphClockCmd(RCC_FB_LED, ENABLE);
000010  2101              MOVS     r1,#1
000012  2038              MOVS     r0,#0x38
000014  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;76     
;;;77     	/*
;;;78     		配置所有的LED指示灯GPIO为推挽输出模式
;;;79     		由于将GPIO设置为输出时，GPIO输出寄存器的值缺省是0，因此会驱动LED点亮.
;;;80     		这是我不希望的，因此在改变GPIO为输出前，先关闭LED指示灯
;;;81     	*/
;;;82         //初始状态为关闭
;;;83         //继电器不用先关闭，初始化模式后为低电平
;;;84     	bsp_LedOff(1);//继电器out1
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       bsp_LedOff
;;;85         g_tDoorStatus.doorA.switcherStatus = NC;
00001e  2000              MOVS     r0,#0
000020  4925              LDR      r1,|L3.184|
000022  7008              STRB     r0,[r1,#0]
;;;86     	bsp_LedOff(2);//继电器out2
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       bsp_LedOff
;;;87         g_tDoorStatus.doorB.switcherStatus = NC;
00002a  2000              MOVS     r0,#0
00002c  4922              LDR      r1,|L3.184|
00002e  7088              STRB     r0,[r1,#2]
;;;88     	bsp_LedOff(3);//系统状态灯
000030  2003              MOVS     r0,#3
000032  f7fffffe          BL       bsp_LedOff
;;;89     
;;;90     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000036  2003              MOVS     r0,#3
000038  f88d0002          STRB     r0,[sp,#2]
;;;91     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	/* 推挽输出模式 */
00003c  2010              MOVS     r0,#0x10
00003e  f88d0003          STRB     r0,[sp,#3]
;;;92     	
;;;93     	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_LED1;
000042  0180              LSLS     r0,r0,#6
000044  f8ad0000          STRH     r0,[sp,#0]
;;;94     	GPIO_Init(GPIO_PORT_LED1, &GPIO_InitStructure);
000048  4669              MOV      r1,sp
00004a  481e              LDR      r0,|L3.196|
00004c  f7fffffe          BL       GPIO_Init
;;;95     
;;;96     	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_LED2;
000050  f44f5080          MOV      r0,#0x1000
000054  f8ad0000          STRH     r0,[sp,#0]
;;;97     	GPIO_Init(GPIO_PORT_LED2, &GPIO_InitStructure);
000058  4669              MOV      r1,sp
00005a  481a              LDR      r0,|L3.196|
00005c  f7fffffe          BL       GPIO_Init
;;;98     
;;;99     	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_LED3;
000060  2020              MOVS     r0,#0x20
000062  f8ad0000          STRH     r0,[sp,#0]
;;;100    	GPIO_Init(GPIO_PORT_LED3, &GPIO_InitStructure);
000066  4669              MOV      r1,sp
000068  4817              LDR      r0,|L3.200|
00006a  f7fffffe          BL       GPIO_Init
;;;101    
;;;102    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_ALARM_LED1 | GPIO_PIN_ALARM_BEEP1 | GPIO_PIN_ALARM_LED2 | GPIO_PIN_ALARM_BEEP2;
00006e  200f              MOVS     r0,#0xf
000070  f8ad0000          STRH     r0,[sp,#0]
;;;103    	GPIO_Init(GPIO_PORT_ALARM, &GPIO_InitStructure);
000074  4669              MOV      r1,sp
000076  4813              LDR      r0,|L3.196|
000078  f7fffffe          BL       GPIO_Init
;;;104        
;;;105    
;;;106    //两根门吸反馈线
;;;107        GPIO_InitStructure.GPIO_Pin  = GPIO_PIN_FB1;
00007c  f44f6000          MOV      r0,#0x800
000080  f8ad0000          STRH     r0,[sp,#0]
;;;108        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000084  2003              MOVS     r0,#3
000086  f88d0002          STRB     r0,[sp,#2]
;;;109    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00008a  2004              MOVS     r0,#4
00008c  f88d0003          STRB     r0,[sp,#3]
;;;110    	GPIO_Init(GPIO_PORT_FB1, &GPIO_InitStructure);
000090  4669              MOV      r1,sp
000092  480c              LDR      r0,|L3.196|
000094  f7fffffe          BL       GPIO_Init
;;;111        
;;;112        GPIO_InitStructure.GPIO_Pin  = GPIO_PIN_FB2;
000098  2004              MOVS     r0,#4
00009a  f8ad0000          STRH     r0,[sp,#0]
;;;113        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00009e  2003              MOVS     r0,#3
0000a0  f88d0002          STRB     r0,[sp,#2]
;;;114    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
0000a4  2004              MOVS     r0,#4
0000a6  f88d0003          STRB     r0,[sp,#3]
;;;115    	GPIO_Init(GPIO_PORT_FB2, &GPIO_InitStructure);
0000aa  4669              MOV      r1,sp
0000ac  4807              LDR      r0,|L3.204|
0000ae  f7fffffe          BL       GPIO_Init
;;;116    }
0000b2  bd08              POP      {r3,pc}
;;;117    
                          ENDP

                  |L3.180|
                          DCD      openDoor
                  |L3.184|
                          DCD      g_tDoorStatus
                  |L3.188|
                          DCD      closeDoor
                  |L3.192|
                          DCD      readFeedBack
                  |L3.196|
                          DCD      0x40011000
                  |L3.200|
                          DCD      0x40010c00
                  |L3.204|
                          DCD      0x40011400

                          AREA ||i.bsp_IsLedOn||, CODE, READONLY, ALIGN=2

                  bsp_IsLedOn PROC
;;;213    */
;;;214    uint8_t bsp_IsLedOn(uint8_t _no)
000000  4601              MOV      r1,r0
;;;215    {
;;;216    	if (_no == 1)
000002  2901              CMP      r1,#1
000004  d108              BNE      |L4.24|
;;;217    	{
;;;218    		if ((GPIO_PORT_LED1->ODR & GPIO_PIN_LED1) == 0)
000006  4810              LDR      r0,|L4.72|
000008  68c0              LDR      r0,[r0,#0xc]
00000a  f4106f80          TST      r0,#0x400
00000e  d101              BNE      |L4.20|
;;;219    		{
;;;220    			return 1;
000010  2001              MOVS     r0,#1
                  |L4.18|
;;;221    		}
;;;222    		return 0;
;;;223    	}
;;;224    	else if (_no == 2)
;;;225    	{
;;;226    		if ((GPIO_PORT_LED2->ODR & GPIO_PIN_LED2) == 0)
;;;227    		{
;;;228    			return 1;
;;;229    		}
;;;230    		return 0;
;;;231    	}
;;;232    	else if (_no == 3)
;;;233    	{
;;;234    		if ((GPIO_PORT_LED3->ODR & GPIO_PIN_LED3) == 0)
;;;235    		{
;;;236    			return 1;
;;;237    		}
;;;238    		return 0;
;;;239    	}
;;;240    //	else if (_no == 4)
;;;241    //	{
;;;242    //		if ((GPIO_PORT_LED4->ODR & GPIO_PIN_LED4) == 0)
;;;243    //		{
;;;244    //			return 1;
;;;245    //		}
;;;246    //		return 0;
;;;247    //	}
;;;248    
;;;249    	return 0;
;;;250    }
000012  4770              BX       lr
                  |L4.20|
000014  2000              MOVS     r0,#0                 ;222
000016  e7fc              B        |L4.18|
                  |L4.24|
000018  2902              CMP      r1,#2                 ;224
00001a  d108              BNE      |L4.46|
00001c  480a              LDR      r0,|L4.72|
00001e  68c0              LDR      r0,[r0,#0xc]          ;226
000020  f4105f80          TST      r0,#0x1000            ;226
000024  d101              BNE      |L4.42|
000026  2001              MOVS     r0,#1                 ;228
000028  e7f3              B        |L4.18|
                  |L4.42|
00002a  2000              MOVS     r0,#0                 ;230
00002c  e7f1              B        |L4.18|
                  |L4.46|
00002e  2903              CMP      r1,#3                 ;232
000030  d108              BNE      |L4.68|
000032  4806              LDR      r0,|L4.76|
000034  6800              LDR      r0,[r0,#0]            ;234
000036  f0100f20          TST      r0,#0x20              ;234
00003a  d101              BNE      |L4.64|
00003c  2001              MOVS     r0,#1                 ;236
00003e  e7e8              B        |L4.18|
                  |L4.64|
000040  2000              MOVS     r0,#0                 ;238
000042  e7e6              B        |L4.18|
                  |L4.68|
000044  2000              MOVS     r0,#0                 ;249
000046  e7e4              B        |L4.18|
;;;251    
                          ENDP

                  |L4.72|
                          DCD      0x40011000
                  |L4.76|
                          DCD      0x40010c0c

                          AREA ||i.bsp_LedOff||, CODE, READONLY, ALIGN=2

                  bsp_LedOff PROC
;;;155    */
;;;156    void bsp_LedOff(uint8_t _no)
000000  1e41              SUBS     r1,r0,#1
;;;157    {
;;;158    	_no--;
000002  b2c8              UXTB     r0,r1
;;;159    
;;;160    	if (_no == 0)
000004  b920              CBNZ     r0,|L5.16|
;;;161    	{
;;;162    		GPIO_PORT_LED1->BSRR = GPIO_PIN_LED1;
000006  f44f6180          MOV      r1,#0x400
00000a  4a07              LDR      r2,|L5.40|
00000c  6111              STR      r1,[r2,#0x10]
00000e  e00a              B        |L5.38|
                  |L5.16|
;;;163    	}
;;;164    	else if (_no == 1)
000010  2801              CMP      r0,#1
000012  d103              BNE      |L5.28|
;;;165    	{
;;;166    		GPIO_PORT_LED2->BSRR = GPIO_PIN_LED2;
000014  0301              LSLS     r1,r0,#12
000016  4a04              LDR      r2,|L5.40|
000018  6111              STR      r1,[r2,#0x10]
00001a  e004              B        |L5.38|
                  |L5.28|
;;;167    	}
;;;168    	else if (_no == 2)
00001c  2802              CMP      r0,#2
00001e  d102              BNE      |L5.38|
;;;169    	{
;;;170    		GPIO_PORT_LED3->BSRR = GPIO_PIN_LED3;
000020  2120              MOVS     r1,#0x20
000022  4a02              LDR      r2,|L5.44|
000024  6011              STR      r1,[r2,#0]
                  |L5.38|
;;;171    	}
;;;172    //	else if (_no == 3)
;;;173    //	{
;;;174    //		GPIO_PORT_LED4->BSRR = GPIO_PIN_LED4;
;;;175    //	}
;;;176    }
000026  4770              BX       lr
;;;177    
                          ENDP

                  |L5.40|
                          DCD      0x40011000
                  |L5.44|
                          DCD      0x40010c10

                          AREA ||i.bsp_LedOn||, CODE, READONLY, ALIGN=2

                  bsp_LedOn PROC
;;;125    */
;;;126    void bsp_LedOn(uint8_t _no)
000000  1e41              SUBS     r1,r0,#1
;;;127    {
;;;128    	_no--;
000002  b2c8              UXTB     r0,r1
;;;129    
;;;130    	if (_no == 0)
000004  b920              CBNZ     r0,|L6.16|
;;;131    	{
;;;132    		GPIO_PORT_LED1->BRR = GPIO_PIN_LED1;
000006  f44f6180          MOV      r1,#0x400
00000a  4a07              LDR      r2,|L6.40|
00000c  6151              STR      r1,[r2,#0x14]
00000e  e00a              B        |L6.38|
                  |L6.16|
;;;133    	}
;;;134    	else if (_no == 1)
000010  2801              CMP      r0,#1
000012  d103              BNE      |L6.28|
;;;135    	{
;;;136    		GPIO_PORT_LED2->BRR = GPIO_PIN_LED2;
000014  0301              LSLS     r1,r0,#12
000016  4a04              LDR      r2,|L6.40|
000018  6151              STR      r1,[r2,#0x14]
00001a  e004              B        |L6.38|
                  |L6.28|
;;;137    	}
;;;138    	else if (_no == 2)
00001c  2802              CMP      r0,#2
00001e  d102              BNE      |L6.38|
;;;139    	{
;;;140    		GPIO_PORT_LED3->BRR = GPIO_PIN_LED3;
000020  2120              MOVS     r1,#0x20
000022  4a02              LDR      r2,|L6.44|
000024  6011              STR      r1,[r2,#0]
                  |L6.38|
;;;141    	}
;;;142    //	else if (_no == 3)
;;;143    //	{
;;;144    //		GPIO_PORT_LED4->BRR = GPIO_PIN_LED4;
;;;145    //	}
;;;146    }
000026  4770              BX       lr
;;;147    
                          ENDP

                  |L6.40|
                          DCD      0x40011000
                  |L6.44|
                          DCD      0x40010c14

                          AREA ||i.bsp_LedToggle||, CODE, READONLY, ALIGN=2

                  bsp_LedToggle PROC
;;;185    */
;;;186    void bsp_LedToggle(uint8_t _no)
000000  2801              CMP      r0,#1
;;;187    {
;;;188    	if (_no == 1)
000002  d106              BNE      |L7.18|
;;;189    	{
;;;190    		GPIO_PORT_LED1->ODR ^= GPIO_PIN_LED1;
000004  490c              LDR      r1,|L7.56|
000006  68c9              LDR      r1,[r1,#0xc]
000008  f4816180          EOR      r1,r1,#0x400
00000c  4a0a              LDR      r2,|L7.56|
00000e  60d1              STR      r1,[r2,#0xc]
000010  e010              B        |L7.52|
                  |L7.18|
;;;191    	}
;;;192    	else if (_no == 2)
000012  2802              CMP      r0,#2
000014  d106              BNE      |L7.36|
;;;193    	{
;;;194    		GPIO_PORT_LED2->ODR ^= GPIO_PIN_LED2;
000016  4908              LDR      r1,|L7.56|
000018  68c9              LDR      r1,[r1,#0xc]
00001a  f4815180          EOR      r1,r1,#0x1000
00001e  4a06              LDR      r2,|L7.56|
000020  60d1              STR      r1,[r2,#0xc]
000022  e007              B        |L7.52|
                  |L7.36|
;;;195    	}
;;;196    	else if (_no == 3)
000024  2803              CMP      r0,#3
000026  d105              BNE      |L7.52|
;;;197    	{
;;;198    		GPIO_PORT_LED3->ODR ^= GPIO_PIN_LED3;
000028  4904              LDR      r1,|L7.60|
00002a  6809              LDR      r1,[r1,#0]
00002c  f0810120          EOR      r1,r1,#0x20
000030  4a02              LDR      r2,|L7.60|
000032  6011              STR      r1,[r2,#0]
                  |L7.52|
;;;199    	}
;;;200    //	else if (_no == 4)
;;;201    //	{
;;;202    //		GPIO_PORT_LED4->ODR ^= GPIO_PIN_LED4;
;;;203    //	}
;;;204    }
000034  4770              BX       lr
;;;205    
                          ENDP

000036  0000              DCW      0x0000
                  |L7.56|
                          DCD      0x40011000
                  |L7.60|
                          DCD      0x40010c0c

                          AREA ||i.closeDoor||, CODE, READONLY, ALIGN=2

                  closeDoor PROC
;;;296    //根据对应关系关门,还要传入何种关门方式
;;;297    static void closeDoor(SingleRelation_T *singleRelation, enum ReaderOrButton_Enum openWay)
000000  b570              PUSH     {r4-r6,lr}
;;;298    {
000002  4603              MOV      r3,r0
000004  460e              MOV      r6,r1
;;;299        uint8_t low_a;
;;;300        uint8_t high_b;
;;;301        switch(openWay)
000006  b136              CBZ      r6,|L8.22|
000008  2e01              CMP      r6,#1
00000a  d005              BEQ      |L8.24|
00000c  2e02              CMP      r6,#2
00000e  d019              BEQ      |L8.68|
000010  2e03              CMP      r6,#3
000012  d12e              BNE      |L8.114|
000014  e017              B        |L8.70|
                  |L8.22|
;;;302        {
;;;303            case e_READER_A:
;;;304            case e_READER_B:
000016  bf00              NOP      
                  |L8.24|
;;;305                low_a = singleRelation->reader_switcher & 0x01;//继电器a
000018  7818              LDRB     r0,[r3,#0]
00001a  f0000401          AND      r4,r0,#1
;;;306                high_b = (singleRelation->reader_switcher >> 4) & 0x01;//继电器b
00001e  7818              LDRB     r0,[r3,#0]
000020  f3c01500          UBFX     r5,r0,#4,#1
;;;307                if(low_a == 1)
000024  b12c              CBZ      r4,|L8.50|
;;;308                {
;;;309                    bsp_LedOff(1);
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       bsp_LedOff
;;;310                    g_tDoorStatus.doorA.switcherStatus = NC;
00002c  2000              MOVS     r0,#0
00002e  4912              LDR      r1,|L8.120|
000030  7008              STRB     r0,[r1,#0]
                  |L8.50|
;;;311                }
;;;312                if(high_b == 1)
000032  2d01              CMP      r5,#1
000034  d105              BNE      |L8.66|
;;;313                {
;;;314                    bsp_LedOff(2);
000036  2002              MOVS     r0,#2
000038  f7fffffe          BL       bsp_LedOff
;;;315                    g_tDoorStatus.doorB.switcherStatus = NC;
00003c  2000              MOVS     r0,#0
00003e  490e              LDR      r1,|L8.120|
000040  7088              STRB     r0,[r1,#2]
                  |L8.66|
;;;316                }
;;;317                break;
000042  e017              B        |L8.116|
                  |L8.68|
;;;318            
;;;319            case e_BUTTON_A:
;;;320            case e_BUTTON_B:
000044  bf00              NOP      
                  |L8.70|
;;;321                low_a = singleRelation->button_switcher & 0x01;//继电器a
000046  7858              LDRB     r0,[r3,#1]
000048  f0000401          AND      r4,r0,#1
;;;322                high_b = (singleRelation->button_switcher >> 4) & 0x01;//继电器b
00004c  7858              LDRB     r0,[r3,#1]
00004e  f3c01500          UBFX     r5,r0,#4,#1
;;;323                if(low_a == 1)
000052  b12c              CBZ      r4,|L8.96|
;;;324                {
;;;325                    bsp_LedOff(1);
000054  2001              MOVS     r0,#1
000056  f7fffffe          BL       bsp_LedOff
;;;326                    g_tDoorStatus.doorA.switcherStatus = NC;
00005a  2000              MOVS     r0,#0
00005c  4906              LDR      r1,|L8.120|
00005e  7008              STRB     r0,[r1,#0]
                  |L8.96|
;;;327                }
;;;328                if(high_b == 1)
000060  2d01              CMP      r5,#1
000062  d105              BNE      |L8.112|
;;;329                {
;;;330                    bsp_LedOff(2);
000064  2002              MOVS     r0,#2
000066  f7fffffe          BL       bsp_LedOff
;;;331                    g_tDoorStatus.doorB.switcherStatus = NC;
00006a  2000              MOVS     r0,#0
00006c  4902              LDR      r1,|L8.120|
00006e  7088              STRB     r0,[r1,#2]
                  |L8.112|
;;;332                }
;;;333                break;
000070  e000              B        |L8.116|
                  |L8.114|
;;;334                
;;;335            default:
;;;336                break;
000072  bf00              NOP      
                  |L8.116|
000074  bf00              NOP                            ;317
;;;337        } 
;;;338    }
000076  bd70              POP      {r4-r6,pc}
;;;339    
                          ENDP

                  |L8.120|
                          DCD      g_tDoorStatus

                          AREA ||i.openDoor||, CODE, READONLY, ALIGN=2

                  openDoor PROC
;;;252    //根据对应关系开门
;;;253    static void openDoor(SingleRelation_T *singleRelation, enum ReaderOrButton_Enum openWay)
000000  b570              PUSH     {r4-r6,lr}
;;;254    {
000002  4603              MOV      r3,r0
000004  460e              MOV      r6,r1
;;;255        uint8_t low_a;
;;;256        uint8_t high_b;
;;;257        switch(openWay)
000006  b136              CBZ      r6,|L9.22|
000008  2e01              CMP      r6,#1
00000a  d005              BEQ      |L9.24|
00000c  2e02              CMP      r6,#2
00000e  d019              BEQ      |L9.68|
000010  2e03              CMP      r6,#3
000012  d12e              BNE      |L9.114|
000014  e017              B        |L9.70|
                  |L9.22|
;;;258        {
;;;259            case e_READER_A:
;;;260            case e_READER_B:
000016  bf00              NOP      
                  |L9.24|
;;;261                low_a = singleRelation->reader_switcher & 0x01;//继电器a
000018  7818              LDRB     r0,[r3,#0]
00001a  f0000401          AND      r4,r0,#1
;;;262                high_b = (singleRelation->reader_switcher >> 4) & 0x01;//继电器b
00001e  7818              LDRB     r0,[r3,#0]
000020  f3c01500          UBFX     r5,r0,#4,#1
;;;263                if(low_a == 1)
000024  b12c              CBZ      r4,|L9.50|
;;;264                {
;;;265                    bsp_LedOn(1);
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       bsp_LedOn
;;;266                    g_tDoorStatus.doorA.switcherStatus = NO;
00002c  2001              MOVS     r0,#1
00002e  4912              LDR      r1,|L9.120|
000030  7008              STRB     r0,[r1,#0]
                  |L9.50|
;;;267                }
;;;268                if(high_b == 1)
000032  2d01              CMP      r5,#1
000034  d105              BNE      |L9.66|
;;;269                {
;;;270                    bsp_LedOn(2);
000036  2002              MOVS     r0,#2
000038  f7fffffe          BL       bsp_LedOn
;;;271                    g_tDoorStatus.doorB.switcherStatus = NO;
00003c  2001              MOVS     r0,#1
00003e  490e              LDR      r1,|L9.120|
000040  7088              STRB     r0,[r1,#2]
                  |L9.66|
;;;272                }
;;;273                break;
000042  e017              B        |L9.116|
                  |L9.68|
;;;274            
;;;275            case e_BUTTON_A:
;;;276            case e_BUTTON_B:
000044  bf00              NOP      
                  |L9.70|
;;;277                low_a = singleRelation->button_switcher & 0x01;//继电器a
000046  7858              LDRB     r0,[r3,#1]
000048  f0000401          AND      r4,r0,#1
;;;278                high_b = (singleRelation->button_switcher >> 4) & 0x01;//继电器b
00004c  7858              LDRB     r0,[r3,#1]
00004e  f3c01500          UBFX     r5,r0,#4,#1
;;;279                if(low_a == 1)
000052  b12c              CBZ      r4,|L9.96|
;;;280                {
;;;281                    bsp_LedOn(1);
000054  2001              MOVS     r0,#1
000056  f7fffffe          BL       bsp_LedOn
;;;282                    g_tDoorStatus.doorA.switcherStatus = NO;
00005a  2001              MOVS     r0,#1
00005c  4906              LDR      r1,|L9.120|
00005e  7008              STRB     r0,[r1,#0]
                  |L9.96|
;;;283                }
;;;284                if(high_b == 1)
000060  2d01              CMP      r5,#1
000062  d105              BNE      |L9.112|
;;;285                {
;;;286                    bsp_LedOn(2);
000064  2002              MOVS     r0,#2
000066  f7fffffe          BL       bsp_LedOn
;;;287                    g_tDoorStatus.doorB.switcherStatus = NO;
00006a  2001              MOVS     r0,#1
00006c  4902              LDR      r1,|L9.120|
00006e  7088              STRB     r0,[r1,#2]
                  |L9.112|
;;;288                }
;;;289                break;
000070  e000              B        |L9.116|
                  |L9.114|
;;;290                
;;;291            default:
;;;292                break;
000072  bf00              NOP      
                  |L9.116|
000074  bf00              NOP                            ;273
;;;293        }  
;;;294    }
000076  bd70              POP      {r4-r6,pc}
;;;295    
                          ENDP

                  |L9.120|
                          DCD      g_tDoorStatus

                          AREA ||i.readFeedBack||, CODE, READONLY, ALIGN=2

                  readFeedBack PROC
;;;340    //检测门吸反馈
;;;341    static void readFeedBack(void)
000000  b510              PUSH     {r4,lr}
;;;342    {
;;;343        if(READ_FB1 == 0)//0表示低电平
000002  f44f6100          MOV      r1,#0x800
000006  480c              LDR      r0,|L10.56|
000008  f7fffffe          BL       GPIO_ReadInputDataBit
00000c  b918              CBNZ     r0,|L10.22|
;;;344        {
;;;345            //门吸反馈的低电平表示常闭NC
;;;346            g_tDoorStatus.doorA.feedBackStatus = NC;
00000e  2000              MOVS     r0,#0
000010  490a              LDR      r1,|L10.60|
000012  7048              STRB     r0,[r1,#1]
000014  e002              B        |L10.28|
                  |L10.22|
;;;347        }
;;;348        else g_tDoorStatus.doorA.feedBackStatus = NO;
000016  2001              MOVS     r0,#1
000018  4908              LDR      r1,|L10.60|
00001a  7048              STRB     r0,[r1,#1]
                  |L10.28|
;;;349        
;;;350        //if(READ_FB2 == 0)
;;;351        if(GPIO_ReadInputDataBit(GPIO_PORT_FB2, GPIO_PIN_FB2) == 0)
00001c  2104              MOVS     r1,#4
00001e  4808              LDR      r0,|L10.64|
000020  f7fffffe          BL       GPIO_ReadInputDataBit
000024  b918              CBNZ     r0,|L10.46|
;;;352        {
;;;353            g_tDoorStatus.doorB.feedBackStatus = NC;
000026  2100              MOVS     r1,#0
000028  4804              LDR      r0,|L10.60|
00002a  70c1              STRB     r1,[r0,#3]
00002c  e002              B        |L10.52|
                  |L10.46|
;;;354        }
;;;355        else g_tDoorStatus.doorB.feedBackStatus = NO;
00002e  2101              MOVS     r1,#1
000030  4802              LDR      r0,|L10.60|
000032  70c1              STRB     r1,[r0,#3]
                  |L10.52|
;;;356    }
000034  bd10              POP      {r4,pc}
;;;357    
                          ENDP

000036  0000              DCW      0x0000
                  |L10.56|
                          DCD      0x40011000
                  |L10.60|
                          DCD      g_tDoorStatus
                  |L10.64|
                          DCD      0x40011400

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_tDoorStatus
                          %        16

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\Led\\bsp_led.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_bsp_led_c_ba23b041____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_bsp_led_c_ba23b041____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_bsp_led_c_ba23b041____REVSH|
#line 128
|__asm___9_bsp_led_c_ba23b041____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
