; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\ds1302.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\ds1302.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\RTX\inc -I..\..\RTX\portable -I..\..\User\CpuFlash -I..\..\User\CRC8_16 -I..\..\User\DS1302 -I..\..\User\DWT -I..\..\User\IIC -I..\..\User\IWDG -I..\..\User\Key -I..\..\User\Led -I..\..\User\Net -I..\..\User\Protocal -I..\..\User\Reader -I..\..\User\SPI -I..\..\User\Timer -I..\..\User\Uart -I..\..\User\Param -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\ds1302.crf ..\..\User\DS1302\ds1302.c]
                          THUMB

                          AREA ||i.checkTime||, CODE, READONLY, ALIGN=1

                  checkTime PROC
;;;141    //检查时间，若电池没电，年为0，则写寄存器
;;;142    static void checkTime()
000000  b51c              PUSH     {r2-r4,lr}
;;;143    {
;;;144        uint8_t time[5];
;;;145        ds1302_readtime(time, 5);
000002  2105              MOVS     r1,#5
000004  4668              MOV      r0,sp
000006  f7fffffe          BL       ds1302_readtime
;;;146        if(time[0] < 18)//复位后读到的年为1
00000a  f89d0000          LDRB     r0,[sp,#0]
00000e  2812              CMP      r0,#0x12
000010  da03              BGE      |L1.26|
;;;147        {
;;;148            write_1302(0x80, 0);
000012  2100              MOVS     r1,#0
000014  2080              MOVS     r0,#0x80
000016  f7fffffe          BL       write_1302
                  |L1.26|
;;;149        }
;;;150    }
00001a  bd1c              POP      {r2-r4,pc}
;;;151    
                          ENDP


                          AREA ||i.ds1302_GPIO_Configuration||, CODE, READONLY, ALIGN=2

                  ds1302_GPIO_Configuration PROC
;;;15     /*PA5配置为开漏模式，此模式下能够实现真正的双向IO口*/
;;;16     void ds1302_GPIO_Configuration(void)
000000  b508              PUSH     {r3,lr}
;;;17     {
;;;18       GPIO_InitTypeDef GPIO_InitStruct;
;;;19       /* 打开GPIO时钟 */
;;;20        //RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);//LED程序中提前初始化好了
;;;21         
;;;22       GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP;
000002  2010              MOVS     r0,#0x10
000004  f88d0003          STRB     r0,[sp,#3]
;;;23       GPIO_InitStruct.GPIO_Pin = ds1302clk|ds1302rst;
000008  2005              MOVS     r0,#5
00000a  f8ad0000          STRH     r0,[sp,#0]
;;;24       GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
00000e  2003              MOVS     r0,#3
000010  f88d0002          STRB     r0,[sp,#2]
;;;25       GPIO_Init(DS1302_PORT, &GPIO_InitStruct);
000014  4669              MOV      r1,sp
000016  4808              LDR      r0,|L2.56|
000018  f7fffffe          BL       GPIO_Init
;;;26       
;;;27       GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_OD;
00001c  2014              MOVS     r0,#0x14
00001e  f88d0003          STRB     r0,[sp,#3]
;;;28       GPIO_InitStruct.GPIO_Pin = ds1302dat;
000022  2002              MOVS     r0,#2
000024  f8ad0000          STRH     r0,[sp,#0]
;;;29       GPIO_Init(DS1302_PORT, &GPIO_InitStruct);
000028  4669              MOV      r1,sp
00002a  4803              LDR      r0,|L2.56|
00002c  f7fffffe          BL       GPIO_Init
;;;30         
;;;31       checkTime();
000030  f7fffffe          BL       checkTime
;;;32     }
000034  bd08              POP      {r3,pc}
;;;33     
                          ENDP

000036  0000              DCW      0x0000
                  |L2.56|
                          DCD      0x40010c00

                          AREA ||i.ds1302_readtime||, CODE, READONLY, ALIGN=2

                  ds1302_readtime PROC
;;;117    }
;;;118    void ds1302_readtime(uint8_t *time, uint8_t len)//处理数据并通过串口打印
000000  b570              PUSH     {r4-r6,lr}
;;;119    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;120      uint8_t i=0;
000006  2400              MOVS     r4,#0
;;;121      //static uint8_t s=1;
;;;122      for(i=0;i<len;i++)
000008  bf00              NOP      
00000a  e006              B        |L3.26|
                  |L3.12|
;;;123      {
;;;124        time[i]=read_1302(readAddr[i]);
00000c  4910              LDR      r1,|L3.80|
00000e  5d08              LDRB     r0,[r1,r4]
000010  f7fffffe          BL       read_1302
000014  5528              STRB     r0,[r5,r4]
000016  1c60              ADDS     r0,r4,#1              ;122
000018  b2c4              UXTB     r4,r0                 ;122
                  |L3.26|
00001a  42b4              CMP      r4,r6                 ;122
00001c  dbf6              BLT      |L3.12|
;;;125      }//读数据已经完成
;;;126      
;;;127      //BCD转10进制
;;;128      for(i=0;i<len;i++)
00001e  2400              MOVS     r4,#0
000020  e012              B        |L3.72|
                  |L3.34|
;;;129      {
;;;130        time[i]=time[i]%16 + (time[i]/16)*10;//秒个位数据+秒十位数据*10
000022  5d28              LDRB     r0,[r5,r4]
000024  17c2              ASRS     r2,r0,#31
000026  eb007212          ADD      r2,r0,r2,LSR #28
00002a  1112              ASRS     r2,r2,#4
00002c  eba01202          SUB      r2,r0,r2,LSL #4
000030  5d29              LDRB     r1,[r5,r4]
000032  17cb              ASRS     r3,r1,#31
000034  eb017313          ADD      r3,r1,r3,LSR #28
000038  111b              ASRS     r3,r3,#4
00003a  eb030383          ADD      r3,r3,r3,LSL #2
00003e  eb020243          ADD      r2,r2,r3,LSL #1
000042  552a              STRB     r2,[r5,r4]
000044  1c60              ADDS     r0,r4,#1              ;128
000046  b2c4              UXTB     r4,r0                 ;128
                  |L3.72|
000048  42b4              CMP      r4,r6                 ;128
00004a  dbea              BLT      |L3.34|
;;;131      }
;;;132      //此时已转换成10进制数，g[i]里面存放的是秒分时日月周年的各个位数据
;;;133      //而此时的time【i】里面存放的则是秒分时日月周年的十位数据
;;;134      
;;;135    //  if(s!=(time[0]+g[0]))
;;;136    //    printf("20%d%d年%d%d月%d%d日%d%d:%d%d:%d%d 星期%d\r\n",\
;;;137    //      time[6],g[6],time[4],g[4],time[3],g[3],time[2],g[2],time[1],g[1],time[0],g[0],g[5]);
;;;138    //  s=time[0]+g[0];	
;;;139    }
00004c  bd70              POP      {r4-r6,pc}
;;;140    
                          ENDP

00004e  0000              DCW      0x0000
                  |L3.80|
                          DCD      readAddr

                          AREA ||i.ds1302_settime||, CODE, READONLY, ALIGN=2

                  ds1302_settime PROC
;;;101    }
;;;102    void ds1302_settime(uint8_t *time, uint8_t len)//初始化1302
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;103    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;104      uint8_t i=0,j=0;
000008  2400              MOVS     r4,#0
00000a  2700              MOVS     r7,#0
;;;105      write_1302(0x8e,0x00);//去除写保护
00000c  2100              MOVS     r1,#0
00000e  208e              MOVS     r0,#0x8e
000010  f7fffffe          BL       write_1302
;;;106      for(i=0;i<len;i++)//转BCD码
000014  bf00              NOP      
000016  e00e              B        |L4.54|
                  |L4.24|
;;;107      {
;;;108        j=time[i]%10;//个位数部分
000018  5d28              LDRB     r0,[r5,r4]
00001a  210a              MOVS     r1,#0xa
00001c  fb90f2f1          SDIV     r2,r0,r1
000020  fb010012          MLS      r0,r1,r2,r0
000024  b2c7              UXTB     r7,r0
;;;109        time[i]=(time[i]/10)*16+j;	
000026  5d28              LDRB     r0,[r5,r4]
000028  fb90f0f1          SDIV     r0,r0,r1
00002c  eb071000          ADD      r0,r7,r0,LSL #4
000030  5528              STRB     r0,[r5,r4]
000032  1c60              ADDS     r0,r4,#1              ;106
000034  b2c4              UXTB     r4,r0                 ;106
                  |L4.54|
000036  42b4              CMP      r4,r6                 ;106
000038  dbee              BLT      |L4.24|
;;;110      }
;;;111      for(i=0;i<len;i++)//进行对时
00003a  2400              MOVS     r4,#0
00003c  e006              B        |L4.76|
                  |L4.62|
;;;112      {
;;;113        write_1302(writeAddr[i],time[i]);
00003e  5d29              LDRB     r1,[r5,r4]
000040  4a06              LDR      r2,|L4.92|
000042  5d10              LDRB     r0,[r2,r4]
000044  f7fffffe          BL       write_1302
000048  1c60              ADDS     r0,r4,#1              ;111
00004a  b2c4              UXTB     r4,r0                 ;111
                  |L4.76|
00004c  42b4              CMP      r4,r6                 ;111
00004e  dbf6              BLT      |L4.62|
;;;114        
;;;115      }
;;;116      write_1302(0x8e,0x80);//加写保护
000050  2180              MOVS     r1,#0x80
000052  208e              MOVS     r0,#0x8e
000054  f7fffffe          BL       write_1302
;;;117    }
000058  e8bd81f0          POP      {r4-r8,pc}
;;;118    void ds1302_readtime(uint8_t *time, uint8_t len)//处理数据并通过串口打印
                          ENDP

                  |L4.92|
                          DCD      writeAddr

                          AREA ||i.read_1302||, CODE, READONLY, ALIGN=2

                  read_1302 PROC
;;;55     }
;;;56     uint8_t read_1302(uint8_t add)//读数据
000000  b570              PUSH     {r4-r6,lr}
;;;57     {
000002  4606              MOV      r6,r0
;;;58       uint8_t i=0,dat1=0x00;
000004  2500              MOVS     r5,#0
000006  2400              MOVS     r4,#0
;;;59       GPIO_ResetBits(DS1302_PORT,ds1302rst);
000008  2104              MOVS     r1,#4
00000a  481a              LDR      r0,|L5.116|
00000c  f7fffffe          BL       GPIO_ResetBits
;;;60       GPIO_ResetBits(DS1302_PORT,ds1302clk);
000010  2101              MOVS     r1,#1
000012  4818              LDR      r0,|L5.116|
000014  f7fffffe          BL       GPIO_ResetBits
;;;61       //ds1302rst=0;
;;;62       //ds1302clk=0;
;;;63       bsp_DelayUS(3);//略微延时2us
000018  2003              MOVS     r0,#3
00001a  f7fffffe          BL       bsp_DelayUS
;;;64       GPIO_SetBits(DS1302_PORT,ds1302rst);
00001e  2104              MOVS     r1,#4
000020  4814              LDR      r0,|L5.116|
000022  f7fffffe          BL       GPIO_SetBits
;;;65       //ds1302rst=1;
;;;66       bsp_DelayUS(3);//时间要大约3us
000026  2003              MOVS     r0,#3
000028  f7fffffe          BL       bsp_DelayUS
;;;67       write_1302byte(add);//先写寄存器的地址
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       write_1302byte
;;;68       for(i=0;i<8;i++)
000032  bf00              NOP      
000034  e012              B        |L5.92|
                  |L5.54|
;;;69       {
;;;70         GPIO_SetBits(DS1302_PORT,ds1302clk);
000036  2101              MOVS     r1,#1
000038  480e              LDR      r0,|L5.116|
00003a  f7fffffe          BL       GPIO_SetBits
;;;71         //ds1302clk=1;
;;;72         dat1>>=1;
00003e  1064              ASRS     r4,r4,#1
;;;73         GPIO_ResetBits(DS1302_PORT,ds1302clk);
000040  2101              MOVS     r1,#1
000042  480c              LDR      r0,|L5.116|
000044  f7fffffe          BL       GPIO_ResetBits
;;;74         //ds1302clk=0;//拉低时钟线，以便于数据的读入
;;;75         if(GPIO_ReadInputDataBit(DS1302_PORT,ds1302dat)==1)//数据线此时为高电平
000048  2102              MOVS     r1,#2
00004a  480a              LDR      r0,|L5.116|
00004c  f7fffffe          BL       GPIO_ReadInputDataBit
000050  2801              CMP      r0,#1
000052  d101              BNE      |L5.88|
;;;76         {dat1=dat1|0x80;}
000054  f0440480          ORR      r4,r4,#0x80
                  |L5.88|
000058  1c68              ADDS     r0,r5,#1              ;68
00005a  b2c5              UXTB     r5,r0                 ;68
                  |L5.92|
00005c  2d08              CMP      r5,#8                 ;68
00005e  dbea              BLT      |L5.54|
;;;77       }
;;;78       bsp_DelayUS(1);
000060  2001              MOVS     r0,#1
000062  f7fffffe          BL       bsp_DelayUS
;;;79       GPIO_ResetBits(DS1302_PORT,ds1302rst);
000066  2104              MOVS     r1,#4
000068  4802              LDR      r0,|L5.116|
00006a  f7fffffe          BL       GPIO_ResetBits
;;;80       //ds1302rst=0;
;;;81       return dat1;
00006e  4620              MOV      r0,r4
;;;82     }
000070  bd70              POP      {r4-r6,pc}
;;;83     void write_1302(uint8_t add,uint8_t dat)//向指定寄存器写入一个字节的数据
                          ENDP

000072  0000              DCW      0x0000
                  |L5.116|
                          DCD      0x40010c00

                          AREA ||i.write_1302||, CODE, READONLY, ALIGN=2

                  write_1302 PROC
;;;82     }
;;;83     void write_1302(uint8_t add,uint8_t dat)//向指定寄存器写入一个字节的数据
000000  b570              PUSH     {r4-r6,lr}
;;;84     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;85       GPIO_ResetBits(DS1302_PORT,ds1302rst);
000006  2104              MOVS     r1,#4
000008  4811              LDR      r0,|L6.80|
00000a  f7fffffe          BL       GPIO_ResetBits
;;;86       GPIO_ResetBits(DS1302_PORT,ds1302clk);
00000e  2101              MOVS     r1,#1
000010  480f              LDR      r0,|L6.80|
000012  f7fffffe          BL       GPIO_ResetBits
;;;87       //ds1302rst=0;
;;;88       //ds1302clk=0;
;;;89       bsp_DelayUS(1);//略微延时
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       bsp_DelayUS
;;;90       GPIO_SetBits(DS1302_PORT,ds1302rst);
00001c  2104              MOVS     r1,#4
00001e  480c              LDR      r0,|L6.80|
000020  f7fffffe          BL       GPIO_SetBits
;;;91       //ds1302rst=1;
;;;92       bsp_DelayUS(2);//时间大约2us
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       bsp_DelayUS
;;;93       write_1302byte(add);
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       write_1302byte
;;;94       write_1302byte(dat);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       write_1302byte
;;;95       GPIO_ResetBits(DS1302_PORT,ds1302rst);
000036  2104              MOVS     r1,#4
000038  4805              LDR      r0,|L6.80|
00003a  f7fffffe          BL       GPIO_ResetBits
;;;96       GPIO_ResetBits(DS1302_PORT,ds1302clk);
00003e  2101              MOVS     r1,#1
000040  4803              LDR      r0,|L6.80|
000042  f7fffffe          BL       GPIO_ResetBits
;;;97       //ds1302clk=0;
;;;98       //ds1302rst=0;
;;;99       bsp_DelayUS(1);
000046  2001              MOVS     r0,#1
000048  f7fffffe          BL       bsp_DelayUS
;;;100      
;;;101    }
00004c  bd70              POP      {r4-r6,pc}
;;;102    void ds1302_settime(uint8_t *time, uint8_t len)//初始化1302
                          ENDP

00004e  0000              DCW      0x0000
                  |L6.80|
                          DCD      0x40010c00

                          AREA ||i.write_1302byte||, CODE, READONLY, ALIGN=2

                  write_1302byte PROC
;;;33     
;;;34     void write_1302byte(uint8_t dat)//写一个字节的数据sck上升沿写数据
000000  b570              PUSH     {r4-r6,lr}
;;;35     {
000002  4604              MOV      r4,r0
;;;36       uint8_t i=0;
000004  2500              MOVS     r5,#0
;;;37       GPIO_ResetBits(DS1302_PORT,ds1302clk);
000006  2101              MOVS     r1,#1
000008  4813              LDR      r0,|L7.88|
00000a  f7fffffe          BL       GPIO_ResetBits
;;;38       //ds1302clk=0;
;;;39       bsp_DelayUS(2);//延时大约2us
00000e  2002              MOVS     r0,#2
000010  f7fffffe          BL       bsp_DelayUS
;;;40       for(i=0;i<8;i++)
000014  bf00              NOP      
000016  e01c              B        |L7.82|
                  |L7.24|
;;;41       {
;;;42         GPIO_ResetBits(DS1302_PORT,ds1302clk);
000018  2101              MOVS     r1,#1
00001a  480f              LDR      r0,|L7.88|
00001c  f7fffffe          BL       GPIO_ResetBits
;;;43         //ds1302clk=0;
;;;44         if(dat&0x01)
000020  f0140f01          TST      r4,#1
000024  d004              BEQ      |L7.48|
;;;45           GPIO_SetBits(DS1302_PORT,ds1302dat);
000026  2102              MOVS     r1,#2
000028  480b              LDR      r0,|L7.88|
00002a  f7fffffe          BL       GPIO_SetBits
00002e  e003              B        |L7.56|
                  |L7.48|
;;;46         else
;;;47           GPIO_ResetBits(DS1302_PORT,ds1302dat);
000030  2102              MOVS     r1,#2
000032  4809              LDR      r0,|L7.88|
000034  f7fffffe          BL       GPIO_ResetBits
                  |L7.56|
;;;48         //ds1302dat=(dat&0x01);
;;;49         bsp_DelayUS(2);
000038  2002              MOVS     r0,#2
00003a  f7fffffe          BL       bsp_DelayUS
;;;50         GPIO_SetBits(DS1302_PORT,ds1302clk);
00003e  2101              MOVS     r1,#1
000040  4805              LDR      r0,|L7.88|
000042  f7fffffe          BL       GPIO_SetBits
;;;51         //ds1302clk=1;
;;;52         dat>>=1;
000046  1064              ASRS     r4,r4,#1
;;;53         bsp_DelayUS(1);
000048  2001              MOVS     r0,#1
00004a  f7fffffe          BL       bsp_DelayUS
00004e  1c68              ADDS     r0,r5,#1              ;40
000050  b2c5              UXTB     r5,r0                 ;40
                  |L7.82|
000052  2d08              CMP      r5,#8                 ;40
000054  dbe0              BLT      |L7.24|
;;;54       }	
;;;55     }
000056  bd70              POP      {r4-r6,pc}
;;;56     uint8_t read_1302(uint8_t add)//读数据
                          ENDP

                  |L7.88|
                          DCD      0x40010c00

                          AREA ||.data||, DATA, ALIGN=0

                  readAddr
000000  8d898785          DCB      0x8d,0x89,0x87,0x85
000004  83                DCB      0x83
                  writeAddr
000005  8c8886            DCB      0x8c,0x88,0x86
000008  8482              DCB      0x84,0x82

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\DS1302\\ds1302.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_ds1302_c_8342bcb1____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_ds1302_c_8342bcb1____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_ds1302_c_8342bcb1____REVSH|
#line 128
|__asm___8_ds1302_c_8342bcb1____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
