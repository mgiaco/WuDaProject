; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_cpu_flash.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_cpu_flash.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User -I..\..\Libraries\CMSIS\Include -I..\..\RTX\inc -I..\..\RTX\portable -I..\..\User\CpuFlash -I..\..\User\CRC8_16 -I..\..\User\DS1302 -I..\..\User\DWT -I..\..\User\IIC -I..\..\User\IWDG -I..\..\User\Key -I..\..\User\Led -I..\..\User\Net -I..\..\User\Protocal -I..\..\User\Reader -I..\..\User\SPI -I..\..\User\Timer -I..\..\User\Uart -I..\..\User\Param -I..\..\User\ADC -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_cpu_flash.crf ..\..\User\CpuFlash\bsp_cpu_flash.c]
                          THUMB

                          AREA ||i.bsp_CmpCpuFlash||, CODE, READONLY, ALIGN=2

                  bsp_CmpCpuFlash PROC
;;;83     */
;;;84     uint8_t bsp_CmpCpuFlash(uint32_t _ulFlashAddr, uint8_t *_ucpBuf, uint32_t _ulSize)
000000  b5f0              PUSH     {r4-r7,lr}
;;;85     {
000002  4603              MOV      r3,r0
;;;86     	uint32_t i;
;;;87     	uint8_t ucIsEqu;	/* 相等标志 */
;;;88     	uint8_t ucByte;
;;;89     
;;;90     	/* 如果偏移地址超过芯片容量，则不改写输出缓冲区 */
;;;91     	if (_ulFlashAddr + _ulSize > FLASH_BASE_ADDR + FLASH_SIZE)
000004  1898              ADDS     r0,r3,r2
000006  4f0f              LDR      r7,|L1.68|
000008  42b8              CMP      r0,r7
00000a  d901              BLS      |L1.16|
;;;92     	{
;;;93     		return FLASH_PARAM_ERR;		/*　函数参数错误　*/
00000c  2003              MOVS     r0,#3
                  |L1.14|
;;;94     	}
;;;95     
;;;96     	/* 长度为0时返回正确 */
;;;97     	if (_ulSize == 0)
;;;98     	{
;;;99     		return FLASH_IS_EQU;		/* Flash内容和待写入的数据相等 */
;;;100    	}
;;;101    
;;;102    	ucIsEqu = 1;			/* 先假设所有字节和待写入的数据相等，如果遇到任何一个不相等，则设置为 0 */
;;;103    	for (i = 0; i < _ulSize; i++)
;;;104    	{
;;;105    		ucByte = *(uint8_t *)_ulFlashAddr;
;;;106    
;;;107    		if (ucByte != *_ucpBuf)
;;;108    		{
;;;109    			if (ucByte != 0xFF)
;;;110    			{
;;;111    				return FLASH_REQ_ERASE;		/* 需要擦除后再写 */
;;;112    			}
;;;113    			else
;;;114    			{
;;;115    				ucIsEqu = 0;	/* 不相等，需要写 */
;;;116    			}
;;;117    		}
;;;118    
;;;119    		_ulFlashAddr++;
;;;120    		_ucpBuf++;
;;;121    	}
;;;122    
;;;123    	if (ucIsEqu == 1)
;;;124    	{
;;;125    		return FLASH_IS_EQU;	/* Flash内容和待写入的数据相等，不需要擦除和写操作 */
;;;126    	}
;;;127    	else
;;;128    	{
;;;129    		return FLASH_REQ_WRITE;	/* Flash不需要擦除，直接写 */
;;;130    	}
;;;131    }
00000e  bdf0              POP      {r4-r7,pc}
                  |L1.16|
000010  b90a              CBNZ     r2,|L1.22|
000012  2000              MOVS     r0,#0                 ;99
000014  e7fb              B        |L1.14|
                  |L1.22|
000016  2601              MOVS     r6,#1                 ;102
000018  2400              MOVS     r4,#0                 ;103
00001a  e00b              B        |L1.52|
                  |L1.28|
00001c  781d              LDRB     r5,[r3,#0]            ;105
00001e  7808              LDRB     r0,[r1,#0]            ;107
000020  42a8              CMP      r0,r5                 ;107
000022  d004              BEQ      |L1.46|
000024  2dff              CMP      r5,#0xff              ;109
000026  d001              BEQ      |L1.44|
000028  2002              MOVS     r0,#2                 ;111
00002a  e7f0              B        |L1.14|
                  |L1.44|
00002c  2600              MOVS     r6,#0                 ;115
                  |L1.46|
00002e  1c5b              ADDS     r3,r3,#1              ;119
000030  1c49              ADDS     r1,r1,#1              ;120
000032  1c64              ADDS     r4,r4,#1              ;103
                  |L1.52|
000034  4294              CMP      r4,r2                 ;103
000036  d3f1              BCC      |L1.28|
000038  2e01              CMP      r6,#1                 ;123
00003a  d101              BNE      |L1.64|
00003c  2000              MOVS     r0,#0                 ;125
00003e  e7e6              B        |L1.14|
                  |L1.64|
000040  2001              MOVS     r0,#1                 ;129
000042  e7e4              B        |L1.14|
;;;132    
                          ENDP

                  |L1.68|
                          DCD      0x08080000

                          AREA ||i.bsp_GetSector||, CODE, READONLY, ALIGN=1

                  bsp_GetSector PROC
;;;26     */
;;;27     uint32_t bsp_GetSector(uint32_t _ulWrAddr)
000000  4601              MOV      r1,r0
;;;28     {
;;;29     	uint32_t sector = 0;
000002  2000              MOVS     r0,#0
;;;30     
;;;31     	sector = _ulWrAddr & SECTOR_MASK;
000004  0ac8              LSRS     r0,r1,#11
000006  02c0              LSLS     r0,r0,#11
;;;32     
;;;33     	return sector;
;;;34     }
000008  4770              BX       lr
;;;35     
                          ENDP


                          AREA ||i.bsp_ReadCpuFlash||, CODE, READONLY, ALIGN=2

                  bsp_ReadCpuFlash PROC
;;;45     */
;;;46     uint8_t bsp_ReadCpuFlash(uint32_t _ulFlashAddr, uint8_t *_ucpDst, uint32_t _ulSize)
000000  b530              PUSH     {r4,r5,lr}
;;;47     {
000002  4603              MOV      r3,r0
;;;48     	uint32_t i;
;;;49     
;;;50     	/* 如果偏移地址超过芯片容量，则不改写输出缓冲区 */
;;;51     	if (_ulFlashAddr + _ulSize > FLASH_BASE_ADDR + FLASH_SIZE)
000004  1898              ADDS     r0,r3,r2
000006  4d09              LDR      r5,|L3.44|
000008  42a8              CMP      r0,r5
00000a  d901              BLS      |L3.16|
;;;52     	{
;;;53     		return 1;
00000c  2001              MOVS     r0,#1
                  |L3.14|
;;;54     	}
;;;55     
;;;56     	/* 长度为0时不继续操作,否则起始地址为奇地址会出错 */
;;;57     	if (_ulSize == 0)
;;;58     	{
;;;59     		return 1;
;;;60     	}
;;;61     
;;;62     	for (i = 0; i < _ulSize; i++)
;;;63     	{
;;;64     		*_ucpDst++ = *(uint8_t *)_ulFlashAddr++;
;;;65     	}
;;;66     
;;;67     	return 0;
;;;68     }
00000e  bd30              POP      {r4,r5,pc}
                  |L3.16|
000010  b90a              CBNZ     r2,|L3.22|
000012  2001              MOVS     r0,#1                 ;59
000014  e7fb              B        |L3.14|
                  |L3.22|
000016  2400              MOVS     r4,#0                 ;62
000018  e004              B        |L3.36|
                  |L3.26|
00001a  f8130b01          LDRB     r0,[r3],#1            ;64
00001e  f8010b01          STRB     r0,[r1],#1            ;64
000022  1c64              ADDS     r4,r4,#1              ;62
                  |L3.36|
000024  4294              CMP      r4,r2                 ;62
000026  d3f8              BCC      |L3.26|
000028  2000              MOVS     r0,#0                 ;67
00002a  e7f0              B        |L3.14|
;;;69     
                          ENDP

                  |L3.44|
                          DCD      0x08080000

                          AREA ||i.bsp_WriteCpuFlash||, CODE, READONLY, ALIGN=2

                  bsp_WriteCpuFlash PROC
;;;142    */
;;;143    uint8_t bsp_WriteCpuFlash(uint32_t _ulFlashAddr, uint8_t *_ucpSrc, uint32_t _ulSize)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;144    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
;;;145    	uint32_t i;
;;;146    	uint8_t ucRet;
;;;147    	uint16_t usTemp;
;;;148    	FLASH_Status status = FLASH_COMPLETE;
00000a  f04f0904          MOV      r9,#4
;;;149    
;;;150    	/* 如果偏移地址超过芯片容量，则不改写输出缓冲区 */
;;;151    	if (_ulFlashAddr + _ulSize > FLASH_BASE_ADDR + FLASH_SIZE)
00000e  1938              ADDS     r0,r7,r4
000010  4929              LDR      r1,|L4.184|
000012  4288              CMP      r0,r1
000014  d902              BLS      |L4.28|
;;;152    	{
;;;153    		return 1;
000016  2001              MOVS     r0,#1
                  |L4.24|
;;;154    	}
;;;155    
;;;156    	/* 长度为0 时不继续操作  */
;;;157    	if (_ulSize == 0)
;;;158    	{
;;;159    		return 0;
;;;160    	}
;;;161    
;;;162    	/* 长度为奇数时不继续操作  */
;;;163    	if ((_ulSize % 2) != 0)
;;;164    	{
;;;165    		return 1;
;;;166    	}	
;;;167    
;;;168    	ucRet = bsp_CmpCpuFlash(_ulFlashAddr, _ucpSrc, _ulSize);
;;;169    
;;;170    	if (ucRet == FLASH_IS_EQU)
;;;171    	{
;;;172    		return 0;
;;;173    	}
;;;174    
;;;175    	__set_PRIMASK(1);  		/* 关中断 */
;;;176    
;;;177    	/* FLASH 解锁 */
;;;178    	FLASH_Unlock();
;;;179    
;;;180      	/* Clear pending flags (if any) */
;;;181    	FLASH_ClearFlag(FLASH_FLAG_BSY | FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);	
;;;182    
;;;183    	/* 需要擦除 */
;;;184    	if (ucRet == FLASH_REQ_ERASE)
;;;185    	{
;;;186    		status = FLASH_ErasePage(bsp_GetSector(_ulFlashAddr));
;;;187    		if (status != FLASH_COMPLETE)
;;;188    		{
;;;189    			return 2;
;;;190    		}		
;;;191    	}
;;;192    
;;;193    	/* 按字节模式编程（为提高效率，可以按字编程，一次写入4字节） */
;;;194    	for (i = 0; i < _ulSize / 2; i++)
;;;195    	{
;;;196    		//FLASH_ProgramByte(_ulFlashAddr++, *_ucpSrc++);		
;;;197    		usTemp = _ucpSrc[2 * i];
;;;198    		usTemp |= (_ucpSrc[2 * i + 1] << 8);
;;;199    		status = FLASH_ProgramHalfWord(_ulFlashAddr, usTemp);
;;;200    		if (status != FLASH_COMPLETE)
;;;201    		{
;;;202    			break;
;;;203    		}
;;;204    		
;;;205    		_ulFlashAddr += 2;
;;;206    	}
;;;207    
;;;208      	/* Flash 加锁，禁止写Flash控制寄存器 */
;;;209      	FLASH_Lock();
;;;210    
;;;211      	__set_PRIMASK(0);  		/* 开中断 */
;;;212    
;;;213    	if (status == FLASH_COMPLETE)
;;;214    	{
;;;215    		return 0;
;;;216    	}
;;;217    	return 2;
;;;218    }
000018  e8bd9ff0          POP      {r4-r12,pc}
                  |L4.28|
00001c  b90c              CBNZ     r4,|L4.34|
00001e  2000              MOVS     r0,#0                 ;159
000020  e7fa              B        |L4.24|
                  |L4.34|
000022  f0140f01          TST      r4,#1                 ;163
000026  d001              BEQ      |L4.44|
000028  2001              MOVS     r0,#1                 ;165
00002a  e7f5              B        |L4.24|
                  |L4.44|
00002c  4622              MOV      r2,r4                 ;168
00002e  4641              MOV      r1,r8                 ;168
000030  4638              MOV      r0,r7                 ;168
000032  f7fffffe          BL       bsp_CmpCpuFlash
000036  4606              MOV      r6,r0                 ;168
000038  b90e              CBNZ     r6,|L4.62|
00003a  2000              MOVS     r0,#0                 ;172
00003c  e7ec              B        |L4.24|
                  |L4.62|
00003e  2001              MOVS     r0,#1                 ;175
000040  f3808810          MSR      PRIMASK,r0            ;175
000044  bf00              NOP                            ;175
000046  f7fffffe          BL       FLASH_Unlock
00004a  2035              MOVS     r0,#0x35              ;181
00004c  f7fffffe          BL       FLASH_ClearFlag
000050  2e02              CMP      r6,#2                 ;184
000052  d10b              BNE      |L4.108|
000054  4638              MOV      r0,r7                 ;186
000056  f7fffffe          BL       bsp_GetSector
00005a  4683              MOV      r11,r0                ;186
00005c  f7fffffe          BL       FLASH_ErasePage
000060  4681              MOV      r9,r0                 ;186
000062  f1b90f04          CMP      r9,#4                 ;187
000066  d001              BEQ      |L4.108|
000068  2002              MOVS     r0,#2                 ;189
00006a  e7d5              B        |L4.24|
                  |L4.108|
00006c  2500              MOVS     r5,#0                 ;194
00006e  e012              B        |L4.150|
                  |L4.112|
000070  f818a015          LDRB     r10,[r8,r5,LSL #1]    ;197
000074  0068              LSLS     r0,r5,#1              ;198
000076  1c40              ADDS     r0,r0,#1              ;198
000078  f8180000          LDRB     r0,[r8,r0]            ;198
00007c  ea4a2a00          ORR      r10,r10,r0,LSL #8     ;198
000080  4651              MOV      r1,r10                ;199
000082  4638              MOV      r0,r7                 ;199
000084  f7fffffe          BL       FLASH_ProgramHalfWord
000088  4681              MOV      r9,r0                 ;199
00008a  f1b90f04          CMP      r9,#4                 ;200
00008e  d000              BEQ      |L4.146|
000090  e004              B        |L4.156|
                  |L4.146|
000092  1cbf              ADDS     r7,r7,#2              ;205
000094  1c6d              ADDS     r5,r5,#1              ;194
                  |L4.150|
000096  ebb50f54          CMP      r5,r4,LSR #1          ;194
00009a  d3e9              BCC      |L4.112|
                  |L4.156|
00009c  bf00              NOP                            ;202
00009e  f7fffffe          BL       FLASH_Lock
0000a2  2000              MOVS     r0,#0                 ;211
0000a4  f3808810          MSR      PRIMASK,r0            ;211
0000a8  bf00              NOP                            ;211
0000aa  f1b90f04          CMP      r9,#4                 ;213
0000ae  d100              BNE      |L4.178|
0000b0  e7b2              B        |L4.24|
                  |L4.178|
0000b2  2002              MOVS     r0,#2                 ;217
0000b4  e7b0              B        |L4.24|
;;;219    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L4.184|
                          DCD      0x08080000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\CpuFlash\\bsp_cpu_flash.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_bsp_cpu_flash_c_4320bcf1____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_bsp_cpu_flash_c_4320bcf1____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_bsp_cpu_flash_c_4320bcf1____REVSH|
#line 128
|__asm___15_bsp_cpu_flash_c_4320bcf1____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
